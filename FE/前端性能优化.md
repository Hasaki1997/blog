# 计划和度量
优化最好不要放在最后阶段, 要从一开始就有优化意识.

定好目标:
首次渲染低于 1 秒, 响应在 100 ms 以内, 帧率控制在 60 帧, 至少要比你最快的竞争对手还快 20%

[PRPL](https://developers.google.com/web/fundamentals/performance/prpl-pattern/)
- 推送 - 为初始网址路由推送关键资源。
- 渲染 - 渲染初始路由。
- 预缓存 - 预缓存剩余路由。
- 延迟加载 - 延迟加载并按需创建剩余路由。

部分度量标准:
- 首次有效渲染（FMP，是指主要内容出现在页面上所需的时间），
- 重要渲染时间（页面最重要部分渲染完成所需的时间），
- 可交互时间（TTI，是指页面布局已经稳定，关键的页面字体已经可见，主进程可以足够的处理用户的输入 —— 基本的时间标记是，用户可以在 UI 上进行点击和交互），
- 输入响应，接口响应用户操作所需的时间，
- Speed Index，测量填充页面内容的速度。 分数越低越好，
自定义度量，由你的业务需求和用户体验来决定。

选择正确的度量, 不是所有的度量都一样重要。

[RAIL](https://developers.google.com/web/fundamentals/performance/rail?hl=zh-cn) 是一种以用户为中心的性能模型。每个网络应用均具有与其生命周期有关的四个不同方面，且这些方面以不同的方式影响着性能：
Response, Animation, Idle, Load

- 以用户为中心；最终目标不是让您的网站在任何特定设备上都能运行很快，而是使用户满意。
- 立即响应用户；在 100 毫秒以内确认用户输入。
- 设置动画或滚动时，在 10 毫秒以内生成帧。
- 最大程度增加主线程的空闲时间。
- 持续吸引用户；在 1000 毫秒以内呈现交互内容。


# 定义环境

做好技术选型, 并不是每个项目都需要框架

合理使用 [CDN](https://www.zhihu.com/question/36514327?rf=37353035).

CDN 全称:Content Delivery Network或Content Ddistribute Network，即内容分发网络

**基本思路**： 尽可能避开互联网上有可能影响数据传输速度和稳定性的瓶颈和环节，使内容传输的更快、更稳定。通过在网络各处放置节点服务器所构成的在现有的互联网基础之上的一层智能虚拟网络，CDN系统能够实时地根据网络流量和各节点的连接、负载状况以及到用户的距离和响应时间等综合信息将用户的请求重新导向离用户最近的服务节点上。

控制时延无疑是现代信息科技的重要指标，CDN的意图就是尽可能的减少资源在转发、传输、链路抖动等情况下顺利保障信息的连贯性。


**基础架构** ：最简单的CDN网络由一个DNS服务器和几台缓存服务器组成：当用户点击网站页面上的内容URL，经过本地DNS系统解析，DNS系统会最终将域名的解析权交给CNAME指向的CDN专用DNS服务器。CDN的DNS服务器将CDN的全局负载均衡设备IP地址返回用户。用户向CDN的全局负载均衡设备发起内容URL访问请求。CDN全局负载均衡设备根据用户IP地址，以及用户请求的内容URL，选择一台用户所属区域的区域负载均衡设备，告诉用户向这台设备发起请求。区域负载均衡设备会为用户选择一台合适的缓存服务器提供服务，选择的依据包括：根据用户IP地址，判断哪一台服务器距用户最近；根据用户所请求的URL中携带的内容名称，判断哪一台服务器上有用户所需内容；查询各个服务器当前的负载情况，判断哪一台服务器尚有服务能力。基于以上这些条件的综合分析之后，区域负载均衡设备会向全局负载均衡设备返回一台缓存服务器的IP地址。全局负载均衡设备把服务器的IP地址返回给用户。用户向缓存服务器发起请求，缓存服务器响应用户请求，将用户所需内容传送到用户终端。如果这台缓存服务器上并没有用户想要的内容，而区域均衡设备依然将它分配给了用户，那么这台服务器就要向它的上一级缓存服务器请求内容，直至追溯到网站的源服务器将内容拉到本地。

# 构建优化

分清主次

资源（assets）可以分为几类，大致可以分为：

- 针对传统的浏览器，定义基本的核心功能（比如：完全可访问的核心内容）
- 针对多功能浏览器提升功能（比如：丰富多彩的，完美的体验）
- 其他资源（不是绝对需要而且可以被延迟加载的资源，如 Web 字体、不必要的样式、旋转木马脚本、视频播放器、社交媒体按钮、大型图像）

用户的设备可能是落后的

删除无用代码, 作用域提升, 代码分割

客户端渲染还是服务端渲染

http 缓存, cache-control: max-age

# 静态资源优化

压缩

优化图像, [WebP](https://zh.wikipedia.org/zh-hans/WebP), 懒加载

优化字体

# 交付优化
# http2
一旦运行在 HTTPS 上，你至少能够在 service workers 和 server push 方面获得显著的性能提升。

为了获得使用 HTTP/2 最好的效果，可以考虑使用[渐进地加载 CSS](https://jakearchibald.com/2016/link-in-body/)，正如 Chrome 的 Jake Archibald 所推荐的。
# 测试和监控

# 最后
测量实际环境的体验并设定适当的目标。一个好的目标是：第一次有意义的绘制 < 1 s，速度指数 < 1250，在慢速的 3G 网络上的交互 < 5s，对于重复访问，TTI < 2s。优化渲染开始时间和交互时间。


为您的主模板准备关键的 CSS，并将其包含在页面的 <head> 中。（你的预算是 14 KB）。对于 CSS/JS，文件大小不超过 170 KB gzipped（解压后 0.8-1 MB）。


延迟加载尽可能多的脚本，包括您自己的和第三方的脚本——特别是社交媒体按钮、视频播放器和耗时的 JavaScript 脚本。


添加资源提示，使用 dns-lookup、preconnect、prefetch 和 preload 加速传输。


分离 web 字体，并以异步方式加载它们（或切换到系统字体）。


优化图像，并在重要页面（例如登录页面）中考虑使用 WebP。


检查 HTTP 缓存头和安全头是否设置正确。


在服务器上启用 Brotli 或 Zopfli 压缩。（如果做不到，不要忘记启用 Gzip 压缩。）


如果 HTTP/2 可用，启用 HPACK 压缩并开启混合内容警告监控。如果您正在运行 LTS，也可以启用 OCSP stapling。


在 service worker 缓存中尽可能多的缓存资产，如字体、样式、JavaScript 和图像。
