# 操作系统概述
什么是操作系统
- 控制应用程序执行的程序
- 应用程序和计算机硬件间的接口

操作系统的目标

- 方便：使计算机更易于使用
- 有效：允许以更有效的方式使用计算机系统资源
- 扩展能力：在不妨碍服务的前提下，有效地开发、测试和引入新的系统功能

操作系统提供的服务

- 程序开发：如编辑器和调试器
- 程序运行：如加载到内存、初始化I/O设备等
- I/O设备访问：隐藏具体的I/O操作指令
- 文件访问控制：屏蔽存储介质细节
- 系统访问：提供接口，防止未授权访问行为
- 错误检测和响应：软、硬件错误
- 记账：收集资源的利用率信息、监控性能特性

## 系统调用
- 操作系统为应用程序提供的与内核进行交互的一组接口
- 应用程序获取操作系统服务的唯一途径
- 系统调用的特殊性在于规定了应用程序进入内核具体位置，即用户访问内核的路径是事先规定好的。

## 操作系统发展进程
串行处理->简单批处理系统->多道批处理系统->分时系统->实时系统
### 串行处理:
处理机制:
- 无操作系统
- 程序员通过操控控制台运行程序，控制台包括显示灯、触发器、某种类型的输入设备和打印机
- 程序通过输入设备（如卡片机阅读器）载入计算机
- 用户按顺序访问计算机

问题:
- 调度：使用硬拷贝登记来预订机器时间
- 准备时间：加载编译器、源程序，保存目标程序，加载目标程序，链接公用函数等。

### 简单批处理系统:
- 对一批作业按顺序进行自动处理
- 内存中只能存放一道作业
- 作业的自动续接
- 内存保护：保护监控程序所在的内存区域
- 定时器：防止某作业独占系统
- 特权指令：只能由监控程序执行的指令
- 中断：早期计算机模型无此能力

### 多道批处理系统(多道性、调度性、无序性、无交互能力):
- 多道程序设计技术可以显著提高系统设备利用率
- 内存中同时存放多个作业
- 多个作业可并发执行
- 作业调度程序负责作业的调度

### 分时系统(多路性、独立性、及时性、交互性):

分时技术就是把处理器的运行时间分成很短的时间片，按时间片轮流把处理器分配给各联机作业使用。若某个作业在分配给它的时间片内不能完成其计算，则该作业暂时停止运行，把处理器让给其他作业使用，等待下一轮再继续运行。由于计算机速度很快，作业运行轮转得很快，给每个用户的感觉好像是自己独占一台计算机。

- 采用多道程序设计技术处理多个交互作业
- 多个用户共享处理器
- 多个用户通过不同终端同时访问系统

|                | 批处理系统多道程序设计          | 分时           |
|----------------|-----------------------------|----------------|
| 主要目标        | 充分利用处理器                 | 减小响应时间    |
| 操作系统指令源   | 作业控制语言命令 作业提供的命令  | 终端键入的命令   |


### 实时系统(可确定性、可响应性、用户控制、可靠性、故障弱化能力):

系统能够及时（即时）响应外部事件的请求，在规定的时间内完成对该事件的处理，并控制所有实时任务协调一致地运行。
# 并发与进程
## 进程
### 进程概念
- 一个正在执行的程序
- 计算机中正在运行的程序的一个实例
- 可分配给处理器并由处理器执行的一个实体
- 由下述表征的活动单元
- 一个单一顺序线程
- 一个当前状态
- 一组相关系统资源

### 进程的组成
- 一段可执行的程序
- 程序所需要的相关数据（变量、工作空间、缓冲区等）
- 程序的执行上下文（execution context）
- 进程状态（process state）
- 操作系统用来管理和控制进程所需的所有数据

## 内存管理
### 存储管理的任务
- 进程隔离：每个进程拥有独立的地址空间，互不干扰
- 自动分配和管理：动态分配，对程序员透明
- 支持模块化程序设计：能够动态加载、销毁程序员定义的模块
- 保护和访问控制：一个应用程序不能任意访问其它程序的存储空间
- 长期存储：关机后仍能长时间存储信息

存储管理的实现方式: 文件系统 + 虚拟存储

文件系统
- 实现了长期存储
- 文件
  - 一个有名称的对象
  - 访问控制和保护的基本单元

虚拟存储
- 程序以逻辑方式访问存储器
- 多作业同时驻留内存
- 每个作业部分驻留
- 换入、换出机制

## 操作系统的4类典型安全问题
- 可用性
  保护系统不被中断
- 机密性
  保证用户不能读取未授权访问的数据
- 完整性
  保护数据不被未授权修改
- 认证
  涉及用户身份的正确认证和消息或数据的合法性


- 并发与并行

> 你吃饭吃到一半，电话来了，你一直到吃完了以后才去接，这就说明你不支持并发也不支持并行。
> 
> 你吃饭吃到一半，电话来了，你停了下来接了电话，接完后继续吃饭，这说明你支持并发。
> 
> 你吃饭吃到一半，电话来了，你一边打电话一边吃饭，这说明你支持并行。
> 
> 并发的关键是你有处理多个任务的能力，不一定要同时。
> 
> 并行的关键是你有同时处理多个任务的能力。
> 
> https://www.zhihu.com/question/33515481

## 操作系统的体系结构

无结构 -> 模块化结构 -> 分层式结构 -> 微内核结构

### 微内核
实现思想: 在操作系统内核中只留下一些最基本的功能，而将其它服务尽可能地从内核中分离出去，用若干个运行在用户态的服务器进程来实现，形成“客户/服务器模式”。普通用户进程通过内核向服务器进程发送请求。

机制与策略
- 机制：实现某一功能的具体执行机构——怎么做
- 策略：方法或原则，用以优化功能实现——做什么

机制与策略的分离

如基于优先级的进程调度中，选择进程，为之分配处理机，使之运行属于机制部分；而为每个进程设定优先级则属于策略部分。

微内核的基本功能

- 进程管理
- 低级存储器管理
- 中断和陷入处理

优点
- 提高了系统的可扩展性
- 增强了系统的可靠性
- 可移植性好
- 提供了对分布式系统的支持


缺点
- 运行效率有所降低：
- 消息传递开销+模式切换开销

## 现代操作系统的特征
- 微内核体系结构
- 分布式操作系统
- 多线程
- 面向对象设计
- 对称多处理

    - 性能高
    - 可用性强
    - 可以增量增长
    - 可扩展性


# 进程与控制
## 进程概览
### 概念

> 来自维基百科

> 进程（英语：process），是指计算机中已运行的程序。进程为曾经是分时系统的基本运作单位。在面向进程设计的系统（如早期的UNIX，Linux 2.4及更早的版本）中，进程是程序的基本执行实体；在面向线程设计的系统（如当代多数操作系统、Linux 2.6及更新的版本）中，进程本身不是基本运行单位，而是线程的容器。程序本身只是指令、数据及其组织形式的描述，进程才是程序（那些指令和数据）的真正运行实例。若干进程有可能与同一个程序相关系，且每个进程皆可以同步（循序）或异步（平行）的方式独立运行。现代计算机系统可在同一段时间内以进程的形式将多个程序加载到存储器中，并借由时间共享（或称时分复用），以在一个处理器上表现出同时（平行性）运行的感觉。同样的，使用多线程技术（多线程即每一个线程都代表一个进程内的一个独立执行上下文）的操作系统或计算机体系结构，同样程序的平行线程，可在多CPU主机或网络上真正同时运行（在不同的CPU上）。

> 操作系统(精髓与设计原理) 中的定义

> - 一个正在执行的程序
> - 一个正在计算机上执行的程序实例
> - 能分配给处理器并由处理器执行的实体
> - 由一组执行的指令, 一个当前状态和一组相关的系统资源表征的活动单元

系统中同时存在的诸进程相互独立，也相互关联。例如，当进程创建另一进程后，父子进程就以某种形式继续保持关联。
如UNIX中，初始化进程是其他所有进程的始祖，与其子女后裔构成一个进程组。
Windows中，没有进程层次的概念，进程地位相等。



进程执行的任意时刻,都可由如下元素来表征:
- 标识符
- 状态
- 优先级
- 程序计数器
- 内存指针
- 上下文数据
- I/O 状态信息
- 记账信息

这些信息放在 PCB(process control block) 中, PCB 由操作系统创建和管理.

用户下达运行程序的命令后，就会产生进程。同一程序可产生多个进程（一对多关系），以允许同时有多位用户运行同一程序，却不会相冲突。

进程需要一些资源才能完成工作，如CPU使用时间、存储器、文件以及I/O设备，且为依序逐一进行，也就是每个CPU核心任何时间内仅能运行一项进程。

进程与线程的区别：进程是计算机管理运行程序的一种方式，一个进程下可包含一个或者多个线程。线程可以理解为子进程。

### 内容
一个计算机系统进程包括（或者说“拥有”）下列数据：

- 那个程序的可执行机器代码的一个在存储器的映像。
- 分配到的存储器（通常是虚拟的一个存储器区域）。存储器的内容包括可执行代码、特定于进程的数据（输入、输出）、调用堆栈、堆栈（用于保存运行时运输中途产生的数据）。
- 分配给该进程的资源的操作系统描述符，诸如文件描述符（Unix术语）或文件句柄（Windows）、数据源和数据终端。
- 安全特性，诸如进程拥有者和进程的权限集（可以容许的操作）。
- 处理器状态（内文），诸如寄存器内容、物理存储器定址等。当进程正在运行时，状态通常存储在寄存器，其他情况在存储器。


### 状态
进程在运行时，状态（state）会改变。所谓状态，就是指进程当前的动作：

- 新生（new）：进程新产生中。
- 运行（running）：正在运行。
- 等待（waiting）：等待某事发生，例如等待用户输入完成。亦称“阻塞”（blocked）
- 就绪（ready）：排班中，等待CPU。
- 结束（terminated）：完成运行。


各状态名称可能随不同操作系统而相异；对于单CPU系统（UP），任何时间可能有多个进程为等待、就绪，但必定仅有一个进程在运行。

![](https://raw.githubusercontent.com/zgw0/blog/master/imgs/processTransformation.png)

多个进程竞争内存资源时可能导致下列现象
- 内存资源紧张, 如何在有限的内存中装入尽量多的进程？
- 无就绪进程，处理机空闲, I/O操作速度远低于CPU计算速度，导致所有进程阻塞，该如何处理？

对换技术（Swapping）

内存中没有就绪进程或内存空间非常紧张时，系统将一个或多个进程的全部或部分程序和数据从内存中换出到磁盘，以腾出部分内存空间。
进程被交换到外存，状态可能变为挂起状态

挂起状态

使执行的进程暂停执行，静止下来，不再参与CPU的竞争，我们把这种静止状态称为挂起状态。

进程挂起的原因
- 进程全部阻塞，处理机空闲
- 系统负荷过重，内存空间紧张
操作系统的需要，操作系统可能需要挂起后台进程或一些服务进程，或某些可能导- 致系统故障的进程。
- 终端用户的请求
- 父进程请求

被挂起进程的特征
- 不能立即执行
- 挂起条件独立于阻塞条件
- 使之挂起的进程：自身、OS、父进程
- 激活挂起进程的进程：实施挂起操作的进程

阻塞与挂起
- 阻塞与否：进程是否等待事件
- 挂起与否：进程是否被换出内存


四种状态组合
- 就绪：进程在内存，准备执行
- 阻塞：进程在内存，等待事件
- 就绪/挂起：进程在外存，只要调入内存并获得CPU即可执行
- 阻塞/挂起：进程在外存，等待事件


![](https://raw.githubusercontent.com/zgw0/blog/master/imgs/processTransformation2.png)

## 内核功能和执行模式
内核（操作系统的核心）
- 操作系统中包含重要系统功能的部分。
- 常驻内存，便于提高操作系统运行效能。

### 功能

不同操作系统对内核的功能范围的设定不同。通常而言，操作系统内核的功能包括

**资源管理功能**
- 进程管理
  - 进程创建和终止
  - 进程的调度和分派
  - 进程切换
  - 进程同步和进程间通信的支持
  - 管理进程控制块 

- 存储管理
  - 为进程分配地址空间
  - 交换
  - 页和段管理

- I/O设备管理
  - I/O缓冲区的管理
  - 为进程分配I/O通道和设备等

**支撑功能**
- 中断处理

  中断处理既是内核的基本功能，也是整个操作系统赖以活动的基础，操作系统的一切重要活动最终都依赖于中断。
- 时钟管理
        
  操作系统的很多功能都依赖于时钟，如时间片控制等。
- 记账（统计、监测）功能

### 执行模式

#### 模式
- 大多数处理器至少支持两种模式：


与操作系统相关的处理器模式——内核模式（系统模式/控制模式）
与用户程序相关的处理器执行模式——用户模式


- 某些指令只能在特权模式下运行


- 读取和修改程序状态字之类的控制寄存器的指令
- 原始I/O指令
- 与内存管理相关的指令
- 部分内存只能在特权模式下访问

#### 采用两种模式的原因

保护操作系统和重要的操作系统表（如PCB）不受程序干扰

#### 处理机如何知道它在什么模式下执行?
程序状态字PSR寄存器中存在指示执行模式的位：

- 当用户调用操作系统服务或中断促发系统例程时，相关位被置为内核模式
- 当从系统服务返回用户进程时，执行模式置为用户模式

#### 模式切换：系统模式和用户模式之间的相互转换
模式切换的原因(用户 -> 系统)
- 系统调用或中断

出现中断时，系统会作如下工作：
- 将程序计数器置为中断处理程序的开始地址
- 从用户模式切换到内核模式，以便中断处理能执行特权指令

模式切换不一定导致进程切换

## 进程控制
- 进程创建与撤销
- 进程阻塞与唤醒
- 挂起与激活
- 进程切换

进程控制由原语来实现, 原语(Primitive):用于完成一定功能的过程。它是原子操作，执行过程中不允许被中断。

### 进程创建与撤销
#### 引起进程创建的典型事件
1. 用户登录, 为终端用户建立一个进程
2. 作业调度(不是进程调度), 为被调度的作业创建进程
3. 提供服务, 如创建打印任务
4. 应用请求, 由应用程序建立多个进程

#### 创建进程的步骤
1. 给新进程分配一个唯一的标识符
2. 为进程分配空间
3. 初始化 PCB
   - 初始化标识信息
   - 初始化处理机状态信息, 如使程序计数器指向程序的入口地址，使栈指针指向栈顶等
   - 初始化进程调度信息, 如设置进程的状态、优先级。

4. 建立连接, 将之插入到就绪或就绪/挂起链表
5. 建立或扩充其他数据结构

#### 进程终止过程
- 根据被终止进程的标识符找到其PCB，读出该进程的状态。
- 若该进程为执行状态，则终止其执行，调度下一个就绪进程执行。
- 若该进程还有子孙进程，还应将其所有子孙进程予以终止，以防他们成为不可控的进程（与具体操作系统的实现密切相关）
- 将该进程所拥有的全部资源，或者归还给其父进程，或者归还给系统。
- 将被终止进程（它的PCB）从所在队列（或链表）中移出，等待其他程序来搜集信息

引起进程终止的事件

- 正常结束：如exit，halt，logoff
- 异常结束：

    - 越界错误
    - 保护错
    - 非法指令
    - 特权指令错
    - 运行超时
    - 等待超时
    - 算术运算错、被0除
    - I/O故障

- 外界干预：

    - 系统员kill进程
    - 父进程终止
    - 父进程请求

### 进程的阻塞与唤醒
#### 引起进程阻塞的事件
- 请求系统服务而得不到满足时，如向系统请求打印，磁盘读数据。
- 启动某种操作而需互斥时：例如进程访问临界区，而临界区暂时被锁定
- 启动某种操作而需同步时：如进程A写，进程B读，则A未写完,B不能读。
- 无新工作可做。

进程阻塞过程
- 正在执行的进程，当发现上述某事件时，由于无法继续执行，于是进程便通过调用阻塞原语block()把自己阻塞。
- 把进程控制块中的现行状态由“执行”改为阻塞，并将PCB插入阻塞队列。
- 调度程序将处理机分配给另一就绪进程，并进行切换。

进程唤醒过程
- 当被阻塞进程所期待的事件出现时，则由有关进程（比如，用完并释放了该I/O设备的进程）调用唤醒原语wakeup()，将等待该事件的进程唤醒。
- 将其PCB中的现行状态由阻塞改为就绪，插入到就绪队列中。

### 进程的挂起与激活
#### 挂起
当出现了引起进程挂起的事件时，系统将利用挂起原语suspend( )将指定进程挂起。

挂起原语的执行过程
- 检查被挂起进程的状态，状态改变：就绪 —> 就绪/挂起；阻塞 —> 阻塞/挂起。
- 插入相应的队列


#### 激活
当发生激活进程的事件时，则可将在外存上处于就绪/挂起状态的进程换入内存。

激活原语的执行过程
- 利用激活原语active()将指定进程从外存调入内存；检查该进程的状态，状态改变：就绪/挂起 —> 就绪；阻塞/挂起 —> 阻塞；
- 插入相应队列。

### 进程的切换
#### 何时会发生进程切换
- 时钟中断：当前执行的进程执行时间超过时间片大小
- I/O中断：操作系统将等待I/O事件的进程改为就绪态，并决定是继续执行当前进程，还是让更高优先级的进程抢占CPU;
- 内存失效：当前进程访问的数据或代码不在内存（引用一个不在内存的字的虚地址）时，当前进程阻塞；
- 陷阱：当前指令的执行出现错误或异常
- 系统调用：处理器移到操作系统内核例程上执行，用户进程阻塞，如file open

#### 进程切换步骤 
- 保存处理器上下文环境，包括程序计数器和其它寄存器
- 更新当前处于运行状态进程的进程控制块
- 将进程的进程控制块移至相应队列（就绪、阻塞等）
- 选择另一进程执行
- 更新其进程控制块信息
- 恢复被选择进程的上下文环境

### UNIX进程控制
- fork()： 创建一个新进程
- exec()： 执行一个可执行程序
- exit()： 终止
- sleep()：暂停一段时间
- pause()：暂停并等待信号
- wait()：等待子进程暂停或终止
- kill()： 发送信号到某个或一组进程
- ptrace() ：设置执行断点(breakpoint)，允许父进程控制子进程的运行

## 线程
**进程回顾**

进程的两个特点

- 资源所有权：一个进程包括一个保存进程映像的虚地址空间，拥有对资源的控制或所有权。
- 调度／执行的基本单位：一个具有状态和优先级，可被被操作系统调度并分派的实体。 

线程的诞生

为区分这两个特点，调度并分派的部分通常称为线程或轻量级进程（light weight process，LWP），而资源所有权的部分通常称为进程。

多线程(multithreading)：操作系统在单个进程内支持多个并发路径的能力。

每个进程中只有一个线程在执行（没有考虑线程的概念）的方法，称作单线程方法。

一个进程中可能有多个线程，每个线程有：
- 执行状态（运行、就绪等）
- 未运行时保存的线程上下文
- 执行栈
- 用于局部变量的静态存储空间
- 与进程内其他线程共享的内存和资源访问

### 线程的优点
- 创建线程的时间少于创建进程时间
- 终止线程比终止进程所花时间少
- 同一进程内线程切换时间，少于进程切换时间
- 线程提高了不同执行程序间通信的效率

在支持线程的操作系统中，调度和分派是在线程基础上完成
- 大多数与线程相关的信息保存在线程级的数据结构中
- 挂起一个进程会挂起内部所有线程
- 终止一个进程会终止内部所有线程

### 线程主要状态
- 运行
- 就绪
- 阻塞

### 和线程变化相关的基本操作
- 派生
- 阻塞
- 解除阻塞
- 结束

### 用户级线程和内核级线程
#### 用户级线程（ULT）
所有线程管理工作由应用程序完成

内核意识不到线程的存在

优点:
- 线程切换不需要内核模式特权
- 调度策略因应用程序不同而不同
- 可以运行在任何操作系统上


缺点:
- 在典型的操作系统中, 许多系统调用都会引起进程阻塞

  因此，当用户级线程执行系统调用时，不仅阻塞当前线程，还将引起同一进程中的其他线程阻塞
- 采用ULT策略，不能利用多处理技术

#### 内核级线程（KLT）
- 线程管理由内核完成
- 应用程序没有线程管理的工作
- 如Windows

优点
- 内核可以把同一个进程内的多个线程调度到多处理器上
- 当一个线程阻塞时，内核可以调度同一进程内的其他线程
- 内核例程本身也可以是多线程的

缺点
- 把控制权从一个线程传递到相同进程内的另一个线程时，需要切换到内核模式

#### 混合方法
- 线程创建在用户空间完成
- 线程调度和同步也由应用程序完成
- 一个应用程序中的多个线程被映射到一些（小于或等于用户级线程数）内核线程上

## 调度

## 同步
## 死锁