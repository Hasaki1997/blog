# 量化设计与分析基础
## 分类： Flynn’s 分类，市场分类
基于指令流和数据流数量的计算机结构分类

串行计算机 SISD

并行计算机: 数据级并行 SIMD

单个数据流进入多个处理单元, 每个处理单元用单个指令流对数据进行独立操作MISD

并行计算机: 线程级或请求级并行 MIMD

Flynn分类模型是抽象和粗略的：

现代的不少并行处理器是SISD、SIMD和MIMD的混合类型。
## 系统结构的原始定义和现在的定义
### 原始定义

由程序员（机器语言）看见的（计算）系统属性，即慨念性结构和功能行为，以区分数据流动和控制逻辑设计的组成及物理实现。

### 现代定义

计算机系统结构（现代定义）：是在满足功能、性能和价格目标的条件下，设计、选择和互连 硬件部件构成计算机。

系统结构覆盖：
- 指令系统设计
- 组成（Organization）:计算机设计方面的高层次

  CPU内部结构、存储器、I/O系统、多处理器、网络

- 硬件: 计算机的具体实现技术

  详细逻辑设计、封装、冷却系统、板级设计，功耗等

<details>

## 实现技术、功耗、成本的趋势，可靠性

## 性能评价指标：响应时间、CPU时间、吞吐量
单位时间内完成的工作总量---吞吐量

## 性能评价方法：基准测试程序，SPEC测试程序集及指标（ SPEC Ratio、 Spec mark ）
</details>

## 量化： Amdahl 定律， CPU 时间计算
采用更快的执行方式后所获得的系统性能提高，与这种执行方式的使用频率或占总执行时间的比例有关。

加速比 = 采用改进措施后计算机的性能 / 没有采用措施时计算机的性能
      = 没有采用改进措施时某任务的执行时间 / 采用改进措施之后某任务的执行时间
Amdahl定律中，加速比与两个因素有关：

改进比例 Fe = 可改进部分的执行时间 / 改进前整个任务的执行时间

改进加速比 Se = 改进前改进部分的执行时间 / 改进后改进部分的执行时间

改进后整个任务的执行时间 T<sub>n</sub> = T<sub>0</sub>(1 - F<sub>e</sub> + F<sub>e</sub> / S<sub>e</sub>)

改进后整个系统的加速比 S<sub>n</sub> = T<sub>0</sub> / T<sub>n</sub>

CPU 的时钟周期数 = ∑I<sub>i</sub> * CPI<sub>i</sub>

CPU 时间 = (∑I<sub>i</sub> * CPI<sub>i</sub>) * 时钟周期
## 性价比：桌面机，服务器

# 指令系统原理与实例
## 指令集系统结构分类及特点

![](https://s2.ax1x.com/2019/06/22/Z9sOMT.png)

`C = A + B` 在这四类系统结构中分别是如何表示和执行的

![](https://s2.ax1x.com/2019/06/22/Z9y8OS.png)
通用寄存器系统结构的分类及特点（寄存器-存储器、寄存器-寄存器）

按照寄存器访问方式划分，有三种寄存器系统结构的计算机：

- register-memory系统结构，任何一条指令都可以访问存储器。
- register-register系统结构，即load-store系统结构，只能通过load和store指令来访问内存（1980年之后设计的计算机都使用这种结构）
- memory-memory系统结构，现实中不存在的结构，把所有的数据都保存在存储器中。

![](https://s2.ax1x.com/2019/06/22/Z96NnO.png)

## 存储器寻址：基本单位、小端与大端模式、对齐访问、最常用寻址方式
小端模式把地址为“X…X000”的字节放在整个字的最低有效位置上，字节内各位编码为76543210

大端模式把地址为“X…X000”的字节放在整个字的最高有效位置上，字节内各位编码为01234567

在许多计算机上，对大于一个字节的数据的寻址必须对齐

如果数据没有对齐，它们的存取需要对存储器进行两次访问才能完成。

如果数据是对齐的，只要存储器与其大小一致，那么这个数据就可以通过一次访问存储器完成

## 常用操作数类型
字符（1B）、半字（ 2B ）、字（ 4B ）、单精度浮点数（ 4B ）、双精度浮点数（ 8B ）。定点几乎都用二进制补码表示，字符几乎都是ASCII编码格式。

## MIPS系统结构也是RISC的主要特点、MIPS的指令长度（32位）
RISC 的特点
- 大多数指令在一个周期内完成
- 运算类指令只能访问寄存器
- 采用 LOAD/SRORE 结构
- 较少的指令数和寻址方式
- 固定的指令格式
- 面向寄存器的结构
- 硬布线控制逻辑
- 注重编译的优化

现代编译器的结构

![](https://s2.ax1x.com/2019/06/22/Z92gu6.png)

MIPS：一种简单64位load-store系统结构

MIPS是一种适合于学习和研究的系统结构模型，是一种应用广泛且容易理解的系统结构。
- 简单的load-store指令系统
- 设计上重视流水线效率，包括固定长度指令编码。
- 使编译器更容易产生高效的目标代码。

MIPS的数据传输和寻址方式
- MIPS数据寻址方式只有立即数和位移量两种方式，这两种方式都是16位的。
- 寄存器间接寻址是通过把0放入16位位移字段中完成的
- 16位绝对寻址字段是通过 R0作为基址寄存器完成的。 
- MIPS的存储器是用64位地址字节寻址的。有一个供软件选择的模式位来决定是高位字节先传格式还是低位字节先传格式。
- 因为它是load-store系统结构，所有的存储器访问都必须通过存储器和通用寄存器GPR或存储器和FPR之间的载入或存储操作完成。
- 所有存储器访问必须是对齐的。

# 流水线：基础和中级概念
## 流水线定义
流水线是利用执行指令操作之间的并行性，实现多条指令重叠执行的技术。
“在前一条指令执行完毕之前开始执行本条指令。”

当今，流水线是实现更快CPU的基本和关键技术。

## 流水线的相关概念
指令预取：在重叠操作中，当前一条指令在执行过程中就需要提前取出后面的指令进行相应处理，这种提前取出后继指令进行相应处理，称为先行（预取）。

- 一个流水线类似自动装配线
- 一个流水线有多个段（级），段间有流水线寄存器
- 每个流水段执行指令或操作的不同部分
- 流水段之间采用同步时钟控制
- 一条指令或操作从流水线一端进入，经过各段，从另一端流出
- 流水线是开发串行指令流中并行性的一种实现技术

## 流水线的分类
（1）按各过程段用时是否相等分类
   
流水线按各过程段用时是否相等可分为均匀流水线和非均匀流水线两种。

（2）按处理的数据类型

按处理的数据类型可分为标量流水处理机和向量流水处理机两种。

（3）按流水线的规模

按流水线的规模可分为操作流水线、指令流水线和宏流水线。

（4）按功能分类 

按流水线完成的功能是否单一，流水线可分为单功能流水线与多功能流水线两种。

（5）按工作方式分类 

流水线按工作方式可分为静态流水线和动态流水线两种。

（6）按连接方式分类 

按照流水线的各个功能段之间是否有反馈信号，可将流水线分为线性流水线和非线性流水线。
## 流水线模型机指令系统、无相关流水线模型机多条指令执行过程，流水线模型机的控制信号的产生
### 流水线处理机的指令系统和指令格式

- ALU操作类型的指令：and,or,add,sub;
- 存储器访问指令：load，store；
- 条件转移指令：bne，beq；
- 无条件转移指令：branch

```
BTAKEN = branch+bne !Z+beqZ
SST = store
SIMM = andi+ori+addi+subi+load+store
WZ = andi+ori+addi+subi+and+or+add+sub
WMEM  = store
SLD  = load
WREG = andi+ori+addi+subi+and+or+add+sub+load
```


## 流水线的主要障碍—流水线冒险
### 冒险分类与有停顿流水线性能
### 结构冒险
- 发生在同一个时钟周期，2条或多条指令想要使用同一个硬件资源
- 引起流水线机器停顿
- 采用资源重复解决：
  - 多重访问寄存器堆
  - 多重访问存储器
  - 没有或没有充分流水功能部件

为什么允许结构冒险
- 减少成本 
  - 如，增加分开的caches需要两倍的存储器带宽
  - 完全流水浮点部件需要很多逻辑门
  - 如果结构冒险不经常发生，则消除冒险的成本就太高 
- 减少部件延迟 
  - 制造流水的功能部件增加延迟
  
    (流水线附加开销-> 流水线寄存器) 

  - 非流水线部件的每个操作需要更少的时钟 
  - 减少延迟有其他的性能好处

### 数据冒险
由于流水线上指令重叠执行，改变了原来串行执行的读/写操作数顺序，使得后面依赖前面指令结果的指令得不到准备好的数据。

直通技术：减少数据冒险停顿

数据可能已经计算好—只是不在寄存器堆中

### 控制冒险


## 流水线模型机中结构相关处理，数据前推、load前推实现，控制相关处理，指令执行的时序图
- 解决相关最简单的方式就是停顿流水线至相关消除
- 停顿意味着为某些指令暂停流水线一个或多个时钟周期。 
- 一条指令被停顿后，其后的所有指令被停顿；该指令之前的指令必须继续执行。
- 一个流水线停顿也称为流水线气泡或气泡。 
- 停顿时，没有任何新的指令被取到流水线。

### 结构相关 
指令重叠执行时，发生硬件资源冲突 
### 数据相关
几条指令重叠执行时，一条指令依赖前面指令的结果却没有准备好（还没有计算或存储）

#### 软件方法解决
- 由编译器插入 nop 指令（软件方法）

#### 暂停数据相关流水线（互锁）
#### 提高流水线处理机性能—内部前推

数据相关本质：一条指令执行时要用到上面指令的计算结果，但这个结果尚未被写入寄存器堆。而实质上，此时结果已经由ALU计算出来了，在流水线寄存器R和C中。

由此，我们可以想到将ALU的计算结果直接拿过来用！在ALU的两个数据输入端各加一个多路器，使R和C中的数据能被直接送到ALU的输入端。这就是所谓的内部前推（internal forwarding）技术。

#### 处理load指令——暂停与内部前推相结合
- 软件方法：由编译器处理。当一条指令与它上面的load指令数据相关时，在它们中间插入两条nop指令，然后优化，用两条不相关的指令替换两条nop指令。替换一条是一条，替换不掉就保留nop指令。
- 硬件方法：由硬件负责检测与load指令的相关性。采用暂停流水线一个周期的方法消除第一个“气泡”。第二个“气泡”用内部前推技术加以消除。

### 控制相关：（流水线上时）
流水线执行转移类指令时，由于转移条件和目标地址没有准备好，使流水线不能按常规取得后续指令

转移指令改变程序顺序执行的特性。由于是流水线操作，在转移发生之前，若干条转移指令的后续指令已被取到流水线处理机中，此时产生转移相关问题（branch hazard），有时也称之为控制相关问题（control hazard）。

一般来讲，若转移指令从取指令到执行完毕需要n个周期的话，则（n-1）条后续指令将受到影响

如果模型机只采用软件方法处理控制相关，则编译器应该在条件转移指令前后加nop指令，无条件转移指令后加nop。

如果模型机只采用假定转移不发生方法，则编译器应该在条件转移指令前加nop指令。
## 精确中断与非精确中断
异常（Exception）事件是指在程序执行过程中，由于操作非法，例如除数为0，结果上溢等，或者用户程序试图执行去处理异特权指令等。这时处理机应该转向特定的程序常事件。

处理的方法一般是先向用户报告哪条指令引起了异常事件以及引起了何种异常事件，然后继续用户程序的执行，或者结束用户程序的执行，返回到操作系统。

异常产生的原因
- I/O 外设请求 
- 用户 OS 服务请求 
- 断点 
- 整数算术运算溢出 
- 浮点算术异常 
- 缺页 
- 未对齐的存储器访问 
- 违反了存储器保护权限 
- 硬件故障
- 未定义指令 

在流水线上出现了异常
1. 强制一个trap指令进入流水线
1. 关掉异常指令及后面指令的所有写操作，直到trap指令流出流水线
目的：避免后续指令改变机器出错时的状态
1. 当trap指令开始执行，唤醒OS ，OS保存异常指令的PC值
1. OS处理异常，然后重新执行出错指令
   - PC←出错指令的地址
   - 重新执行出错指令

### 精确异常
如果流水线可以停下来使异常指令之前的指令能正常结束，异常指令之后的指令能重新启动，则称该流水线是精确异常。意味着：
- 异常指令之前的所有指令正常完成  
- 异常指令及其后的指令没有改变机器的状态。

这个模型下，重新执行就很简单了: 
- 重新恢复执行异常指令 
- 如果它不是一个可恢复执行的指令，则执行下一条指令 

## 经典5段流水线扩展浮点流水线，涉及到的写冲突、相关及处理
### RAW
B 试图在A写一个寄存器之前读它，得到旧的值。 

经常发生，forwarding 可以帮助解决RAW

插入 stalls
### WAW
B 试图在A写一个操作数之前写它。

在B执行后，寄存器应该是B的结果，但是A的结果取代了B的。 

这种情况只发生在多于一个流水段写值的流水线，或长度可变的流水线如FP流水线。

- 加一个Stall
- WAW最简单的处理方法是在ID级,判断该指令要写的寄存器是否与前面已经发射了的指令相同，若相同，则插入空周期。
### WAR
B 试图在A读一个寄存器之前写它。

这种情况，A使用新（错误）的值。

很少发生，因为大多数流水线读值在前写值在后。

然而，可能发生在有复杂寻址方式的CPU中，如自增寻址。

# 指令级并行及其开发

<details>

静态调度的循环展开方法，名相关，寄存器换名（编译器实现）

动态调度，记分牌算法（没有直接消除名相关：靠停顿延迟解决）， Tomasulo算法

动态转移预测，BPB，BTB，前瞻执行的基本概念（前瞻执行的4个阶段、ROB存放内容）

</details>

允许打乱指令的顺序执行，尽量开发指令级并行，减少或消除由指令相关引起的流水线停顿。

## 循环展开
循环展开技术是利用多次复制循环体，并相应调整展开后的指令和循环结束条件，增加有效操作时间、减少控制操作时间。

1. 保证正确性
1. 注意有效性
1. 采用寄存器换名
1. 尽可能减少循环控制中的测试指令和分支指令
1. 注意对存储器数据的相关性分析
1. 注意新的相关性

### 相关
在调换指令技术下，程序中的相关主要有3种：

数据相关、名相关、控制相关
#### 数据相关
如果下面的条件之一成立，则指令j与指令i数据相关：
- 指令j使用指令i产生的结果	
- 指令j与指令k数据相关，指令k与指令i数据相关，则指令j与指令i数据相关。

要保证数据相关指令之间的执行顺序关系，在硬件上如果检测到指令与前面指令间有数据相关，就暂停本指令的执行，插入空操作周期，一直到前面执行指令的结果可以使用为止。这个过程也称为互锁机制。

分析数据相关的主要工作包括：
- 确定指令的相关性，找到所有可能产生停顿的地方。
- 确定必须严格遵守的数据的计算顺序。
- 确定指令的最大相关距离（两条相关指令之间的指令条数）, 确定程序中可能的最大并行性

以上因素决定了程序中到底有多少指令级并行性，是否可以获得
这些并行性。
#### 名相关
指令使用的寄存器或存储器称为名。

如果两条指令使用相同的名，但它们之间没有数据流，则称之为名相关。

指令j与指令i之间名相关有以下两种：
- 反相关：指令i先执行，指令j写的名是指令i读的名。反相关指令间的顺序是必须保证的。反相关就是先读后写相关。
- 输出相关：指令j和指令i写相同的名。输出相关指令的执行顺序是不能颠倒的。输出相关就是写后写相关。

与数据相关比较，名相关的指令间没有数据传送，在不需要调度指令顺序时，程序执行的正确性可以保证。

但是，如果要通过调度改变指令顺序时，就必须消除名相关。由于一条指令中的名改变了，并不影响名相关的另外一条指令的执行，因此，可以通过改变指令中操作数的名字来消除名相关，这就是换名技术。
#### 控制相关
```
if  p1   then{
  S1;
}
S;
if p2 then{
  S2;
};
```
（1）与控制相关的语句或指令（S1或S2）不能移到分支语句或指令之前执行。例如if…then语句中，then后面的语句不能移到if之前执行。

（2）与控制无关的语句或指令（S）不能移到该分支语句或指令之后，从而受这个分支控制。例如if…then语句中，if前的语句不能移到then后面部分执行。

## 调度
静态调度

依靠编译器对代码进行静态调度，以减少相关和冲突。
它不是在程序执行的过程中、而是在编译期间进行代码调度和优化。
通过把相关的指令拉开距离来减少可能产生的停顿。

动态调度（乱序执行）

在程序的执行过程中，依靠专门硬件重新安排指令的执行顺序，来调整相关指令实际执行时的关系，减少数据相关导致的停顿。可以处理编译时未发现的相关如存储器数据相关。

动态调度不能完全消除数据相关，但它能在出现数据相关时尽量避免处理机停顿。

### 记分牌算法
在记分牌算法中，设指令预取到指令队列中，乱序执行需要将基本流水线的译码阶段再分为两个阶段：

(1)流出（发射Issue，IS）：指令译码
      
  指令顺序发射，检查是否存在**结构相关**（还有写后写相关），没有，本指令就流出到对应功能部件。

(2)读操作数（Read Operands，RO）：
     
  检查数据相关，当没有**数据相关**引发的阻塞时，就读操作数（可以乱序）。读到操作数就进入到执行段。
      
IS之前是IF段，RO之后是EXE段。执行阶段紧跟在读操作数之后，工作过程类似于基本流水线。

由于不同指令的执行时间不同，可能会引起指令乱序结束，随之带来的最大问题是:

异常处理比较复杂：不精确异常处理

(精确异常处理如模型机的异常处理)

对于乱序执行及结束的动态流水线上，异常处理是不精确的，因为出现异常的指令其后的指令可能先执行完。出现异常后，难以恢复现场。



















# 存储系统

<details>

Cache存储器的三种映像方式（全相联、直接映像，组相联），物理地址与Cache地址的映射计算，Cache的映像规则，块标识，替换算法，写策略

Cache性能计算：CPU执行时间，平均存储器访问时间（二级cache时，一级cache缺失代价实际上是二级cache的平均访存时间 ）

Cache性能优化的方法，减少缺失率4种，减少缺失代价5种，减少缺失率或缺失代价3种，减少命中时间5种。

虚拟存储器基本概念，页式虚拟存储器，映像规则，查找方法，替换算法，写策略，快表TLB的结构与作用

虚拟存储器与cache的综合

</details>

## cache 概念
- 小而快的存储器，用于改善对慢速存储器的平均访问时间。
- 在计算机结构中，几乎每个部件都是一个cache！
  - 寄存器是变量的“a cache”– —软件管理
  - 一级 cache 是二级 cache 的“a cache”
  - 二级 cache是主存的“a cache”
  - 主存是磁盘（虚拟存储器）的 “a cache”
  - TLB 是页表的“a cache” 
  - 转移预测缓存是预测信息的“a cache”
## 三种映像方式
直接映像：主存中的块能进入（即对应）cache中的唯一块（因为直接映像是1路组相联，即每组中只有1个块），所以只需要把这个唯一的块通过索引找出后比较其标识tag是否与cpu送来的主存地址中的标识tag相等

全相联cache中没有索引字段，因为全相联中只有一个组。
全相联中：主存的块可以进入cache中的任何位置，所以需要把cache中所有块分别取出标识tag与cpu送来的主存中的标识tag进行对比（即需要比较 cache 中所有块的标识tag）

2路组相联, 将cache每组中的两个块分别取出标识tag来与cpu送来的主存地址中的标识tag进行比较（需要同时比较cache的一个组中的2个块的标识tag）。

### 块替换策略

- 随机替换 –— 随机选择被替换的一块

硬件容易实现，需要随机数产生器
均匀使用一组中的各块
可能替换即将被访问的那一块

- 最近最少使用Least-recently used (LRU)——选择一组中最近最少被访问
的块作为被替换块

假定最近被访问的块很可能会一再访问
Cache中需要额外的位记录访问历史 

- 先进先出(FIFO)——选择一组中最先进入cache的一块

## 平均存储器访问时间
![](https://s2.ax1x.com/2019/06/23/ZFePAJ.png)

平均存储器访问时间 = 
指令访存所占比例 ×（命中时间<sub>指令</sub> + 缺失率<sub>指令</sub> × 缺失代价）+
数据访存所占比例 ×（命中时间<sub>数据</sub> + 缺失率<sub>数据</sub> × 缺失代价）

## cache 优化

![](https://s2.ax1x.com/2019/06/23/ZF1RhD.png)