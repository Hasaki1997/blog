# 量化设计与分析基础
## 分类： Flynn’s 分类，市场分类
基于指令流和数据流数量的计算机结构分类

串行计算机 SISD

并行计算机: 数据级并行 SIMD

单个数据流进入多个处理单元, 每个处理单元用单个指令流对数据进行独立操作MISD

并行计算机: 线程级或请求级并行 MIMD

Flynn分类模型是抽象和粗略的：

现代的不少并行处理器是SISD、SIMD和MIMD的混合类型。
## 系统结构的原始定义和现在的定义
### 原始定义

由程序员（机器语言）看见的（计算）系统属性，即慨念性结构和功能行为，以区分数据流动和控制逻辑设计的组成及物理实现。

### 现代定义

计算机系统结构（现代定义）：是在满足功能、性能和价格目标的条件下，设计、选择和互连 硬件部件构成计算机。

系统结构覆盖：
- 指令系统设计
- 组成（Organization）:计算机设计方面的高层次

  CPU内部结构、存储器、I/O系统、多处理器、网络

- 硬件: 计算机的具体实现技术

  详细逻辑设计、封装、冷却系统、板级设计，功耗等

<details>

## 实现技术、功耗、成本的趋势，可靠性

## 性能评价指标：响应时间、CPU时间、吞吐量
单位时间内完成的工作总量---吞吐量

## 性能评价方法：基准测试程序，SPEC测试程序集及指标（ SPEC Ratio、 Spec mark ）
</details>

## 量化： Amdahl 定律， CPU 时间计算
采用更快的执行方式后所获得的系统性能提高，与这种执行方式的使用频率或占总执行时间的比例有关。

加速比 = 采用改进措施后计算机的性能 / 没有采用措施时计算机的性能
      = 没有采用改进措施时某任务的执行时间 / 采用改进措施之后某任务的执行时间
Amdahl定律中，加速比与两个因素有关：

改进比例 Fe = 可改进部分的执行时间 / 改进前整个任务的执行时间

改进加速比 Se = 改进前改进部分的执行时间 / 改进后改进部分的执行时间

改进后整个任务的执行时间 T<sub>n</sub> = T<sub>0</sub>(1 - F<sub>e</sub> + F<sub>e</sub> / S<sub>e</sub>)

改进后整个系统的加速比 S<sub>n</sub> = T<sub>0</sub> / T<sub>n</sub>

CPU 的时钟周期数 = ∑I<sub>i</sub> * CPI<sub>i</sub>

CPU 时间 = (∑I<sub>i</sub> * CPI<sub>i</sub>) * 时钟周期
## 性价比：桌面机，服务器

# 指令系统原理与实例
## 指令集系统结构分类及特点

![](https://s2.ax1x.com/2019/06/22/Z9sOMT.png)

`C = A + B` 在这四类系统结构中分别是如何表示和执行的

![](https://s2.ax1x.com/2019/06/22/Z9y8OS.png)
通用寄存器系统结构的分类及特点（寄存器-存储器、寄存器-寄存器）

按照寄存器访问方式划分，有三种寄存器系统结构的计算机：

- register-memory系统结构，任何一条指令都可以访问存储器。
- register-register系统结构，即load-store系统结构，只能通过load和store指令来访问内存（1980年之后设计的计算机都使用这种结构）
- memory-memory系统结构，现实中不存在的结构，把所有的数据都保存在存储器中。

![](https://s2.ax1x.com/2019/06/22/Z96NnO.png)

## 存储器寻址：基本单位、小端与大端模式、对齐访问、最常用寻址方式
小端模式把地址为“X…X000”的字节放在整个字的最低有效位置上，字节内各位编码为76543210

大端模式把地址为“X…X000”的字节放在整个字的最高有效位置上，字节内各位编码为01234567

在许多计算机上，对大于一个字节的数据的寻址必须对齐

如果数据没有对齐，它们的存取需要对存储器进行两次访问才能完成。

如果数据是对齐的，只要存储器与其大小一致，那么这个数据就可以通过一次访问存储器完成

## 常用操作数类型
字符（1B）、半字（ 2B ）、字（ 4B ）、单精度浮点数（ 4B ）、双精度浮点数（ 8B ）。定点几乎都用二进制补码表示，字符几乎都是ASCII编码格式。

## MIPS系统结构也是RISC的主要特点、MIPS的指令长度（32位）
RISC 的特点
- 大多数指令在一个周期内完成
- 运算类指令只能访问寄存器
- 采用 LOAD/SRORE 结构
- 较少的指令数和寻址方式
- 固定的指令格式
- 面向寄存器的结构
- 硬布线控制逻辑
- 注重编译的优化

现代编译器的结构

![](https://s2.ax1x.com/2019/06/22/Z92gu6.png)

MIPS：一种简单64位load-store系统结构

MIPS是一种适合于学习和研究的系统结构模型，是一种应用广泛且容易理解的系统结构。
- 简单的load-store指令系统
- 设计上重视流水线效率，包括固定长度指令编码。
- 使编译器更容易产生高效的目标代码。

MIPS的数据传输和寻址方式
- MIPS数据寻址方式只有立即数和位移量两种方式，这两种方式都是16位的。
- 寄存器间接寻址是通过把0放入16位位移字段中完成的
- 16位绝对寻址字段是通过 R0作为基址寄存器完成的。 
- MIPS的存储器是用64位地址字节寻址的。有一个供软件选择的模式位来决定是高位字节先传格式还是低位字节先传格式。
- 因为它是load-store系统结构，所有的存储器访问都必须通过存储器和通用寄存器GPR或存储器和FPR之间的载入或存储操作完成。
- 所有存储器访问必须是对齐的。

# 流水线：基础和中级概念
## 流水线定义
流水线是利用执行指令操作之间的并行性，实现多条指令重叠执行的技术。
“在前一条指令执行完毕之前开始执行本条指令。”

当今，流水线是实现更快CPU的基本和关键技术。

## 流水线的相关概念
指令预取：在重叠操作中，当前一条指令在执行过程中就需要提前取出后面的指令进行相应处理，这种提前取出后继指令进行相应处理，称为先行（预取）。

- 一个流水线类似自动装配线
- 一个流水线有多个段（级），段间有流水线寄存器
- 每个流水段执行指令或操作的不同部分
- 流水段之间采用同步时钟控制
- 一条指令或操作从流水线一端进入，经过各段，从另一端流出
- 流水线是开发串行指令流中并行性的一种实现技术

## 流水线的分类
（1）按各过程段用时是否相等分类
   
流水线按各过程段用时是否相等可分为均匀流水线和非均匀流水线两种。

（2）按处理的数据类型

按处理的数据类型可分为标量流水处理机和向量流水处理机两种。

（3）按流水线的规模

按流水线的规模可分为操作流水线、指令流水线和宏流水线。

（4）按功能分类 

按流水线完成的功能是否单一，流水线可分为单功能流水线与多功能流水线两种。

（5）按工作方式分类 

流水线按工作方式可分为静态流水线和动态流水线两种。

（6）按连接方式分类 

按照流水线的各个功能段之间是否有反馈信号，可将流水线分为线性流水线和非线性流水线。
## 流水线模型机指令系统、无相关流水线模型机多条指令执行过程，流水线模型机的控制信号的产生
### 流水线处理机的指令系统和指令格式

- ALU操作类型的指令：and,or,add,sub;
- 存储器访问指令：load，store；
- 条件转移指令：bne，beq；
- 无条件转移指令：branch

```
BTAKEN = branch+bne !Z+beqZ
SST = store
SIMM = andi+ori+addi+subi+load+store
WZ = andi+ori+addi+subi+and+or+add+sub
WMEM  = store
SLD  = load
WREG = andi+ori+addi+subi+and+or+add+sub+load
```


## 流水线的主要障碍—流水线冒险
### 冒险分类与有停顿流水线性能
### 结构冒险
- 发生在同一个时钟周期，2条或多条指令想要使用同一个硬件资源
- 引起流水线机器停顿
- 采用资源重复解决：
  - 多重访问寄存器堆
  - 多重访问存储器
  - 没有或没有充分流水功能部件

为什么允许结构冒险
- 减少成本 
  - 如，增加分开的caches需要两倍的存储器带宽
  - 完全流水浮点部件需要很多逻辑门
  - 如果结构冒险不经常发生，则消除冒险的成本就太高 
- 减少部件延迟 
  - 制造流水的功能部件增加延迟
  
    (流水线附加开销-> 流水线寄存器) 

  - 非流水线部件的每个操作需要更少的时钟 
  - 减少延迟有其他的性能好处

### 数据冒险
由于流水线上指令重叠执行，改变了原来串行执行的读/写操作数顺序，使得后面依赖前面指令结果的指令得不到准备好的数据。

直通技术：减少数据冒险停顿

数据可能已经计算好—只是不在寄存器堆中

### 控制冒险


## 流水线模型机中结构相关处理，数据前推、load前推实现，控制相关处理，指令执行的时序图
- 解决相关最简单的方式就是停顿流水线至相关消除
- 停顿意味着为某些指令暂停流水线一个或多个时钟周期。 
- 一条指令被停顿后，其后的所有指令被停顿；该指令之前的指令必须继续执行。
- 一个流水线停顿也称为流水线气泡或气泡。 
- 停顿时，没有任何新的指令被取到流水线。

### 结构相关 
指令重叠执行时，发生硬件资源冲突 
### 数据相关
几条指令重叠执行时，一条指令依赖前面指令的结果却没有准备好（还没有计算或存储）

#### 软件方法解决
- 由编译器插入 nop 指令（软件方法）

#### 暂停数据相关流水线（互锁）
#### 提高流水线处理机性能—内部前推

数据相关本质：一条指令执行时要用到上面指令的计算结果，但这个结果尚未被写入寄存器堆。而实质上，此时结果已经由ALU计算出来了，在流水线寄存器R和C中。

由此，我们可以想到将ALU的计算结果直接拿过来用！在ALU的两个数据输入端各加一个多路器，使R和C中的数据能被直接送到ALU的输入端。这就是所谓的内部前推（internal forwarding）技术。

#### 处理load指令——暂停与内部前推相结合
- 软件方法：由编译器处理。当一条指令与它上面的load指令数据相关时，在它们中间插入两条nop指令，然后优化，用两条不相关的指令替换两条nop指令。替换一条是一条，替换不掉就保留nop指令。
- 硬件方法：由硬件负责检测与load指令的相关性。采用暂停流水线一个周期的方法消除第一个“气泡”。第二个“气泡”用内部前推技术加以消除。

### 控制相关：（流水线上时）
流水线执行转移类指令时，由于转移条件和目标地址没有准备好，使流水线不能按常规取得后续指令

转移指令改变程序顺序执行的特性。由于是流水线操作，在转移发生之前，若干条转移指令的后续指令已被取到流水线处理机中，此时产生转移相关问题（branch hazard），有时也称之为控制相关问题（control hazard）。

一般来讲，若转移指令从取指令到执行完毕需要n个周期的话，则（n-1）条后续指令将受到影响

如果模型机只采用软件方法处理控制相关，则编译器应该在条件转移指令前后加nop指令，无条件转移指令后加nop。

如果模型机只采用假定转移不发生方法，则编译器应该在条件转移指令前加nop指令。
## 精确中断与非精确中断
异常（Exception）事件是指在程序执行过程中，由于操作非法，例如除数为0，结果上溢等，或者用户程序试图执行去处理异特权指令等。这时处理机应该转向特定的程序常事件。

处理的方法一般是先向用户报告哪条指令引起了异常事件以及引起了何种异常事件，然后继续用户程序的执行，或者结束用户程序的执行，返回到操作系统。

异常产生的原因
- I/O 外设请求 
- 用户 OS 服务请求 
- 断点 
- 整数算术运算溢出 
- 浮点算术异常 
- 缺页 
- 未对齐的存储器访问 
- 违反了存储器保护权限 
- 硬件故障
- 未定义指令 

在流水线上出现了异常
1. 强制一个trap指令进入流水线
1. 关掉异常指令及后面指令的所有写操作，直到trap指令流出流水线
目的：避免后续指令改变机器出错时的状态
1. 当trap指令开始执行，唤醒OS ，OS保存异常指令的PC值
1. OS处理异常，然后重新执行出错指令
   - PC←出错指令的地址
   - 重新执行出错指令

### 精确异常
如果流水线可以停下来使异常指令之前的指令能正常结束，异常指令之后的指令能重新启动，则称该流水线是精确异常。意味着：
- 异常指令之前的所有指令正常完成  
- 异常指令及其后的指令没有改变机器的状态。

这个模型下，重新执行就很简单了: 
- 重新恢复执行异常指令 
- 如果它不是一个可恢复执行的指令，则执行下一条指令 

## 经典5段流水线扩展浮点流水线，涉及到的写冲突、相关及处理
### RAW
B 试图在A写一个寄存器之前读它，得到旧的值。 

经常发生，forwarding 可以帮助解决RAW

插入 stalls
### WAW
B 试图在A写一个操作数之前写它。

在B执行后，寄存器应该是B的结果，但是A的结果取代了B的。 

这种情况只发生在多于一个流水段写值的流水线，或长度可变的流水线如FP流水线。

- 加一个Stall
- WAW最简单的处理方法是在ID级,判断该指令要写的寄存器是否与前面已经发射了的指令相同，若相同，则插入空周期。
### WAR
B 试图在A读一个寄存器之前写它。

这种情况，A使用新（错误）的值。

很少发生，因为大多数流水线读值在前写值在后。

然而，可能发生在有复杂寻址方式的CPU中，如自增寻址。

# 指令级并行及其开发

<details>

静态调度的循环展开方法，名相关，寄存器换名（编译器实现）

动态调度，记分牌算法（没有直接消除名相关：靠停顿延迟解决）， Tomasulo算法

动态转移预测，BPB，BTB，前瞻执行的基本概念（前瞻执行的4个阶段、ROB存放内容）

</details>

允许打乱指令的顺序执行，尽量开发指令级并行，减少或消除由指令相关引起的流水线停顿。

## 循环展开
循环展开技术是利用多次复制循环体，并相应调整展开后的指令和循环结束条件，增加有效操作时间、减少控制操作时间。

1. 保证正确性
1. 注意有效性
1. 采用寄存器换名
1. 尽可能减少循环控制中的测试指令和分支指令
1. 注意对存储器数据的相关性分析
1. 注意新的相关性

### 相关
在调换指令技术下，程序中的相关主要有3种：

数据相关、名相关、控制相关
#### 数据相关
如果下面的条件之一成立，则指令j与指令i数据相关：
- 指令j使用指令i产生的结果	
- 指令j与指令k数据相关，指令k与指令i数据相关，则指令j与指令i数据相关。

要保证数据相关指令之间的执行顺序关系，在硬件上如果检测到指令与前面指令间有数据相关，就暂停本指令的执行，插入空操作周期，一直到前面执行指令的结果可以使用为止。这个过程也称为互锁机制。

分析数据相关的主要工作包括：
- 确定指令的相关性，找到所有可能产生停顿的地方。
- 确定必须严格遵守的数据的计算顺序。
- 确定指令的最大相关距离（两条相关指令之间的指令条数）, 确定程序中可能的最大并行性

以上因素决定了程序中到底有多少指令级并行性，是否可以获得
这些并行性。
#### 名相关
指令使用的寄存器或存储器称为名。

如果两条指令使用相同的名，但它们之间没有数据流，则称之为名相关。

指令j与指令i之间名相关有以下两种：
- 反相关：指令i先执行，指令j写的名是指令i读的名。反相关指令间的顺序是必须保证的。反相关就是先读后写相关。
- 输出相关：指令j和指令i写相同的名。输出相关指令的执行顺序是不能颠倒的。输出相关就是写后写相关。

与数据相关比较，名相关的指令间没有数据传送，在不需要调度指令顺序时，程序执行的正确性可以保证。

但是，如果要通过调度改变指令顺序时，就必须消除名相关。由于一条指令中的名改变了，并不影响名相关的另外一条指令的执行，因此，可以通过改变指令中操作数的名字来消除名相关，这就是换名技术。
#### 控制相关
```
if  p1   then{
  S1;
}
S;
if p2 then{
  S2;
};
```
（1）与控制相关的语句或指令（S1或S2）不能移到分支语句或指令之前执行。例如if…then语句中，then后面的语句不能移到if之前执行。

（2）与控制无关的语句或指令（S）不能移到该分支语句或指令之后，从而受这个分支控制。例如if…then语句中，if前的语句不能移到then后面部分执行。

## 调度
静态调度

依靠编译器对代码进行静态调度，以减少相关和冲突。
它不是在程序执行的过程中、而是在编译期间进行代码调度和优化。
通过把相关的指令拉开距离来减少可能产生的停顿。

动态调度（乱序执行）

在程序的执行过程中，依靠专门硬件重新安排指令的执行顺序，来调整相关指令实际执行时的关系，减少数据相关导致的停顿。可以处理编译时未发现的相关如存储器数据相关。

动态调度不能完全消除数据相关，但它能在出现数据相关时尽量避免处理机停顿。

### 记分牌算法
在记分牌算法中，设指令预取到指令队列中，乱序执行需要将基本流水线的译码阶段再分为两个阶段：

(1)流出（发射Issue，IS）：指令译码
      
  指令顺序发射，检查是否存在**结构相关**（还有写后写相关），没有，本指令就流出到对应功能部件。

(2)读操作数（Read Operands，RO）：
     
  检查数据相关，当没有**数据相关**引发的阻塞时，就读操作数（可以乱序）。读到操作数就进入到执行段。
      
IS之前是IF段，RO之后是EXE段。执行阶段紧跟在读操作数之后，工作过程类似于基本流水线。

由于不同指令的执行时间不同，可能会引起指令乱序结束，随之带来的最大问题是:

异常处理比较复杂：不精确异常处理

(精确异常处理如模型机的异常处理)

对于乱序执行及结束的动态流水线上，异常处理是不精确的，因为出现异常的指令其后的指令可能先执行完。出现异常后，难以恢复现场。

在DLX中，记分牌技术主要用于浮点部件（其延迟大，乱序执行可有效提高性能）。

DLX的指令集结构具有下面的特征：
1. 使用load／store结构。
2. 运算指令只能访问寄存器。
3. 支持寻址方式：变址、立即（8~16位）、寄存器寻址。
4. 支持简单的指令系统，包括：load，store，加，减，寄
    - 存器到寄存器，转移，与，移位，测试相等，测试不等，
    - 分支，跳转，调用，返回。
5. 支持的数据类型：8位、16位和32位整型，64位IEEE754
    - 浮点数。
6. 侧重处理器性能时使用固定指令编码；侧重代码大小时
    - 使用可变长指令编码。
7. 提供至少16个通用寄存器和单独的浮点寄存器，确保所
    - 有的寻址模式都可应用于所有的数据转移指令，并形成
    - 最简指令集。 

记分牌调度算法使用硬件缓冲区，记录当前寄存器、执行部件和被发出的指令的状态。通过这些状态信息来决定一条被发出的指令是否需要等待。如果不需要等待，则指令由执行部件立即执行，否则，一直等到允许指令执行的条件出现为止

在DLX中，记分牌技术主要用于浮点部件（其延迟大，乱序执行可有效提高性能）。

#### 每条指令在流水线中的执行过程
分为四段（设有指令预取部件，因此设指令已经在指令队列中）：
  (1) 流出（发射Issue，记为IS）
      如果本指令所需的功能部件有空闲；并且本指令使用的目的寄存器与其它正在执行的指令的目的寄存器不同，记分牌就向下一阶段流出本指令，并修改记分牌内部的数据记录。
      进入这个阶段需要判断指令间是否存在的结构相关，写后写相关。 

  (2) 读操作数（Read Operand，记为RO）
    记分牌需要监测源操作数寄存器中数据的有效性，如果本指令的源操作数寄存器与前面指令无关，或者一个正在工作的功能部件已经完成了对源寄存器的写操作，那么此操作数有效。
    当操作数有效后，记分牌将启动本指令的功能部件读操作数并开始执行。（换句话说，只有源操作数都就绪时，才进入RO）
    解决了数据的先写后读（RAW）相关。

    通过以上IS、RO二个步骤，记分牌动态检测到结构相关、写后写相关、数据相关，并暂时阻塞相关指令，用延迟解决相关问题。

  (3) 执行（Execution，记为EX）
      
    取到操作数后就可以由功能部件执行指令，允许多条指令同时且乱序执行，不同功能部件需要的时钟周期不同。


  (4) 写结果（Write Result，记为WR）
    
      检测先读后写（WAR）相关：
      
      即，出现以下的情况时，就不允许指令写结果:
      
      前面的某条指令还没有读取操作数（RO），且其某个源操作数寄存器与本指令的目的寄存器相同。

      如果没有先读后写相关，目标寄存器空闲，就将结果写入到目标寄存器中，然后释放本指令使用的所有资源

#### 记分牌需要纪录的信息分为三部分：
(1) 指令状态表

记录正在执行的各条指令已经经过或进入记分牌DLX流水线四段中的哪些段。

(2) 功能部件状态表

记录各个功能部件的状态。每个功能部件在状态表中都由以下九个域来纪录：
- Busy： 指示功能部件是否在工作
- Op： 功能部件当前执行的操作
- Fi： 目的寄存器编号
- Fj，Fk：源寄存器编号
- Qj，Qk：有数据相关时，记录向Fj，Fk中写结果的功能部件
- Rj，Rk：表示Fj，Fk是否就绪（IS段）；是否已经被使用过（RO、EXE、WR段）

(3) 结果寄存器状态表

每个寄存器在表中有一个域，用于记录写入本目的寄存器的功能部件（编号）。如果当前正在运行的功能部件没有需要写入本寄存器结果的，则相应域置为空。

#### 记分牌的性能受限于以下几个方面：

(1) 程序指令中可开发的并行性，即是否存在可以并行执行的不相关的指令。

如果每条指令均与前面的指令相关，那么任何动态调度策略均无法解决流水线停顿的问题。

(2) 记分牌容量。记分牌的容量决定了流水线能在多大范围内寻找不相关指令。

记分牌中，能够被检测相关性指令的集合称为指令窗口。

本节中假设窗口仅仅包含的是一个简单基本块的线性代码，这样就不考虑转移指令的问题。

(3) 功能部件的数目和种类。功能部件的总数决定了结构冲突的严重程度。采用动态调度后结构冲突会更加频繁。

(4) 反相关和输出相关。引起计分牌中先读后写和写后写阻塞。

记分牌技术允许在资源充足时乱序执行。对于数据相关、名相关，通过检测后，延迟相关指令的执行解决相关。由于乱序执行会引起的名相关会增多，因此写后写与先读后写导致的阻塞也会更严重，则会降低处理机的性能。

### Tomasulo动态调度算法

Tomasulo算法将记分牌的关键部分和寄存器换名技术结合在一起。通过寄存器换名消除写后写、先读后写相关引起的停顿。

编译器通过寄存器换名可以解决写后写、先读后写相关。
      
在Tomasulo算法中，寄存器换名通过硬件保留站实现，它保存已经发射和正在发射指令所需的操作数。其基本思想是：

- 尽可能早地取到并缓存一个操作数，只要操作数有效，就将其取到保留站，避免发射指令读操作数时才到寄存器中取数据。
- 指令的执行结果直接送到等待数据的其它保留站中去，而不是通过寄存器传送。
- 一条指令发射时，存放操作数的寄存器名被换成为对应于该寄存器保留站的名称（编号）。

实际上，保留站的数目远多于实际的寄存器，保留站就是存放操作数与结果的虚拟寄存器，对系统结构层透明

保留站（5个）中保存已流出并等待到本功能部件执行的操作（指令）；包括操作数、运算符和用来检测和解决相关的信息。

- 如果该操作的源操作数在寄存器中已经就绪，就将该操作数取来，保存到保留站中；
- 如果操作数还没有计算出来，则保留站中记录这个操作数将由谁计算出来，即指明它由哪个功能部件产生。 

取缓冲（6个）和存缓冲（3个）保存的是读/写存储器的数据和地址：

取缓冲或load缓存（6个），三个功能：
* 保存有效地址的各个部分直至计算完成；
* 等待将要访问存储器的load指令；
* 为已经完成且正在等待CDB的load指令保留结果。

存缓冲（3个）保存的是写存储器的地址、数据。
* 保存有效地址的各个部分直至计算完成；
* 为正在等待数据的store指令保存存储器目标地址；
* 在存储单元可用之前保存地址和要写的数据。

寄存器换名是通过保留站和流出逻辑共同完成的：

- 当指令流出时，如果其操作数还没有计算出来，则将该指令中相应的寄存器名换名为将产生这个操作数的保留站的标识。
- 指令流出到保留站后，其操作数寄存器号或换成了数据本身（如果该数据已经就绪），或换成了保留站的标识，不再与寄存器有关系。
- 这样后面指令对该寄存器的写入操作就不可能产生WAR冲突

#### 指令流水线的分段情况 Tomasulo算法的流水线需三段：
(1) 流出（发射，Issue）：

从指令队列头部取一条指令：
* 如果是浮点操作且有空的保留站（设为r），就把该指令送到该保留站，
并且，如果其中的操作数在寄存器就绪，就将其送入保留站，如果未就
绪，就在保留站中记录产生该操作数的保留站编号。这样，一旦被记录
的保留站完成计算，它将直接把数据送给保留站r。此时就进行了操作数
寄存器名换成了保留站名和对操作数进行缓存，消除了先读后写相关
（即寄存器换名消除先读后写的名相关）  
* 另外，还要完成对寄存器的预约工作，将其设置为接收保留站r的结果。
这实际上相当于提前完成了写操作（预约）。由于指令是按程序顺序流
出，当出现多条指令写同一个结果寄存器时，最后留下的预约结果肯定
是最后一条指令的，就是说消除了写后写冲突的名相关。
* 如果是访存操作且有空的缓冲就发射到缓冲。并记录地址、状态等。
* 如果没有空的保留站和缓冲，即有结构相关，就不发射。

(2) 执行（Execute）：
* 如果保留站的操作数未计算出，就用保留站编号监视CDB，等待所需的计算结果，一旦有结果产生，它将被放到CDB上，本保留站将立即获得该数据。

当二个操作数就绪后，本保留站就用相应的功能部件开始执行指令规定成的操作。这里是等到所有操作数都备齐后才开始执行指令，即靠推迟执行的方法解决先写后读相关。

由于结果数据是从其产生的部件（保留站）直接送到需要它的地方，所以这已经是最大限度地减少了先写后读相关的影响。

* 显然，保留站有可能会出现多条指令在同一时钟周期变成就绪的情况。不同的功能部件可以并行执行，但在一个功能部件内部，就绪的多条指令就得逐条地处理。可以采取随机的方法选择要执行的指令。

* 访存指令：计算有效地址和把有效地址放到load或store缓冲器。load启动读的条件是存储器部件就绪。Store缓冲器中的store指令在执行前必须等到要存入存储器的数据到达。通过按顺序进行有效地址计算来保证程序顺序，有助于避免访问存储器的冲突。

(3) 写结果（Write Result） ：
- 功能部件计算/load读完成后，将结果连同产生该结果的保留站号一起送到CDB上，所有等待本保留站结果的保留站、存缓冲、目标寄存器将同时从CDB上获得所需数据。
- Store指令在这一步完成写存储器：当写入地址和数据都备齐时，将它们送给存储器部件，store指令完成。
- 保留站、寄存器组和load/store缓冲器都包含附加标志信息，用于检测和消除冲突。不同部件的附加信息略有不同。标识字段实际上就是用于换名的一组虚拟寄存器的名称（编号）。

由于用于检测和消除数据相关的数据结构，附加在保留站、寄存器组、存/取缓冲上，不同的部件附加的信息有区别。除取缓冲（数据来自DM）外，各部件的每一个保留站、缓冲或寄存器至少有一个域保存寄存器换名的保留站编号。

可以用4位编号表示：5个保留站、6个取缓冲。这些是产生结果的部件，是判断数据相关的依据。一旦指令发射到保留站等待操作数，它将用产生这个操作数的保留站编号来等待操作数出现在CDB上。

#### 术语和数据结构 

- 标志（tags）:指缓冲或产生结果的保留站编号。

保留站作为扩展的虚拟寄存器使用。通过重命名方法取得更多的虚拟寄存器。

当一条指令流出到保留站后，原来操作数的寄存器名将不再引用

每个保留站有以下6个域：  
- Op：对源操作数S1和S2所进行的操作。
- Vj，Vk：两个就绪源操作数的值。操作数项中，V或Q对应域最多只有一种域有效。
- Qj，Qk：产生源操作数的保留站号。等于0表示操作数在Vj和Vk中或不需要操作数。
- Busy：表示本保留站和相应的功能部件是否空闲。 

存缓冲store有6个域：

- Busy：表示缓冲是否空闲。
- Vk域：保存要存入存储器的数据。无数据相关时，有数据。有数据相关时，为空，由Qk域存产生数据的保留站号。
- Qk域：有数据相关时，存要产生写数据的保留站号。无数据相关，Qk为0，表示写的数据在Vk或没有指令要将结果写入存缓冲。
- A：存store指令的地址。初始时保存指令中的立即数字段；有效地址计算结束后，保存有效地址。     
- Vj： 存已经就绪的寄存器地址分量。
- Qj：存产生有效地址中寄存器地址分量的保留站号。等于0，表示地址分量在Vj中或不需要操作数。

取缓冲load有4个域：
- Busy：标示缓冲是否空闲。  
- A：load指令的地址域。初始时保存偏移量。有效地址计算结束后，保存有效地址。    
- Vj： 存已就绪的寄存器地址分量。
- Qj：同存缓冲的Qj。

Tomasulo算法相对于记分牌技术主要的优点：
- 具有分布的数据相关检测机制和执行机制；
- 寄存器换名消除了数据的写后写和先读后写相关导致的阻塞。 

## 转移预测技术

静态预测方法：无论是采用编译器还是硬件预测，其预测方向是固定不变的。

* 最简单的方法是预测转移总是发生即命中（或者不发生，即不命中）。错误率平均34% 。如模型机的假设转移不发生

* 另一种稍好的方法是根据转移的前后方向来预测转移。据测试程序统计，程序中向后转移的概率高于向前转移，因此，可以预测向后的转移总是发生。 其错误率很难低于30%。

* 一个更精确的技术是基于以前运行时得到的配置文件信息。错误率约14% 左右。花费时间代价。








# 存储系统

<details>

Cache存储器的三种映像方式（全相联、直接映像，组相联），物理地址与Cache地址的映射计算，Cache的映像规则，块标识，替换算法，写策略

Cache性能计算：CPU执行时间，平均存储器访问时间（二级cache时，一级cache缺失代价实际上是二级cache的平均访存时间 ）

Cache性能优化的方法，减少缺失率4种，减少缺失代价5种，减少缺失率或缺失代价3种，减少命中时间5种。

虚拟存储器基本概念，页式虚拟存储器，映像规则，查找方法，替换算法，写策略，快表TLB的结构与作用

虚拟存储器与cache的综合

</details>

## cache 概念
- 小而快的存储器，用于改善对慢速存储器的平均访问时间。
- 在计算机结构中，几乎每个部件都是一个cache！
  - 寄存器是变量的“a cache”– —软件管理
  - 一级 cache 是二级 cache 的“a cache”
  - 二级 cache是主存的“a cache”
  - 主存是磁盘（虚拟存储器）的 “a cache”
  - TLB 是页表的“a cache” 
  - 转移预测缓存是预测信息的“a cache”
## 三种映像方式
直接映像：主存中的块能进入（即对应）cache中的唯一块（因为直接映像是1路组相联，即每组中只有1个块），所以只需要把这个唯一的块通过索引找出后比较其标识tag是否与cpu送来的主存地址中的标识tag相等

全相联cache中没有索引字段，因为全相联中只有一个组。
全相联中：主存的块可以进入cache中的任何位置，所以需要把cache中所有块分别取出标识tag与cpu送来的主存中的标识tag进行对比（即需要比较 cache 中所有块的标识tag）

2路组相联, 将cache每组中的两个块分别取出标识tag来与cpu送来的主存地址中的标识tag进行比较（需要同时比较cache的一个组中的2个块的标识tag）。

### 块替换策略

- 随机替换 –— 随机选择被替换的一块

硬件容易实现，需要随机数产生器
均匀使用一组中的各块
可能替换即将被访问的那一块

- 最近最少使用Least-recently used (LRU)——选择一组中最近最少被访问
的块作为被替换块

假定最近被访问的块很可能会一再访问
Cache中需要额外的位记录访问历史 

- 先进先出(FIFO)——选择一组中最先进入cache的一块

## 平均存储器访问时间
![](https://s2.ax1x.com/2019/06/23/ZFePAJ.png)

平均存储器访问时间 = 
指令访存所占比例 ×（命中时间<sub>指令</sub> + 缺失率<sub>指令</sub> × 缺失代价）+
数据访存所占比例 ×（命中时间<sub>数据</sub> + 缺失率<sub>数据</sub> × 缺失代价）

## cache 优化

![](https://s2.ax1x.com/2019/06/23/ZF1RhD.png)