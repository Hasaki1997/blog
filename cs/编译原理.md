## 语义分析和中间代码生成
### 语义分析概论
#### 语义分析的任务
1. 语义检查
   
   主要进行一致性检查和越界检查

   主要有: 类型检查, 控制流检查(用以保证控制语句有合法的转向点:如不允许goto语句转入case语句流;break语句需要在switch或循环语句)和一致性检查(数组维数是否正确;变量是否已经定义；变量是否重名；case常量不能相同等)

2. 语义处理
   
   说明语句: 登记信息到符号表

   执行语句: 生成中间代码

#### 语法制导翻译

语法制导翻译: 在语法分析的过程中, 根据每个产生式所对应的语义子程序(语义动作)进行翻译(生成中间代码)的方法.

语义子程序(语义动作): 完成语义检查和语义处理. 每一个语句(或语法单位)对应一组语义子程序, 语义子程序实际上描述该语法单位的语义规则, 它的核心任务是生成中间代码.

在描述语义动作(语义子程序)时, 需要给每个文法符号 X 不同的语义值, 如'类型', '种属', '地址', '代码'等. 我们用记号 X.TYPE, X.CAT 或 X.VAL 来表示这些值.

语义子程序不是计值程序, 而是某种中间代码生成**工具**, 语法制导翻译既可以用来生成各种中间代码, 也可以用来直接产生目标指令, 甚至可以用来对输入符号串解释执行.
### 中间代码

中间代码有很多种形式: 三地址形式(四元式), 后缀式, 语法树等, 三地址形式(x = y op z)是最常见的

三地址语句常见形式:

- 二元运算类赋值语句 `x:=y op z`
- 一元运算类赋值语句 `x:=op z`
- 复制类赋值语句 `x:=y`
- 无条件转移语句 `goto L`

### 语义变量和语义函数
编译器在语义分析时, 要用到一些工作单元和子程序, 称它们为语义变量和语义函数

常用的有:

1. i.NAME : 语义变量, 和终结符 i 相关联, 表示 i 对应的变量名.
2. E.PLACE : 语义变量, 和非终结符 E 相关联, 表示与 E 对应的变量在符号表中的位置(若该变量是一个普通变量)或证书编码(若该变量是一个临时变量).
3. newtemp() : 语义函数, 产生一个新的临时变量, 并返回其整数编码 i. 在后面的使用中, 将该临时变量表示为 t<sub>i</sub>.
4. entry(i) : 语义函数, 为名字为 i 的变量查符号表.
5. emit(RESULT, OPD1, oper, OPD2)或emit(RESULT, oper, OPD) : 语义函数, 根据指定的参数产生一个新的三地址语句, 并传输到输出指针 ip 指向的位置, 然后 ip 自动加1, 指向下一个位置
6. error() : 语义函数, 表示出错.

### 翻译

#### 变量语句的翻译

变量说明语句语义分析的工作不需要翻译为中间代码,仅登记信息将被说明的变量的类型及相对存储位置(相对地址)记入符号表(变量表)中.

语义变量及过程

1. offset : 相对位移量,全局变量,初值0
2. T.type : 数据类型
3. T.width : 数据宽度（变量需要的内存单元字节数）
4. enter : 语义过程,根据变量名，将对应的类型和相对地址记入符号表中。
5. 
#### 简单赋值语句的翻译
假设某赋值语句可以用下列文法来描述:

```
A → i:=E
E → i
E → (E1)
E → -E1 
E → E1 op E2
```

翻译方案:

```
A → i:=E      { emit (entry(i), :=, E.PLACE) }
E → i         { E.PLACE:=entry(i) }
E → (E1)      { E.PLACE:= E1.PLACE  }
// 产生式 E → -E1 中的 - 表示一元运算符 uminus
E → -E1       { E.PLACE:=newtemp( ); 
                emit(E.PLACE, uminus, E1.PLACE) }
E → E1 op E2  { E.PLACE:=newtemp( );
                emit(E.PLACE, E1.PLACE, op, E2.PLACE) }
```

#### 控制语句的翻译
##### 布尔表达式的翻译

```
B → b          // b 为true, false 或逻辑变量
B → i1 rop i2
```

布尔表达式可翻译成两个表示转移的三地址语句: 一个用于转移到为真的地方, 称为真出口, 记为 B.T; 另一个用于转移到为假的地方, 称为假出口, 记为 B.F.

由此可以写出上述两个产生式的语义子程序

对产生式 `B → b` 有:

```
B → b { B.T := ip;
        B.F := ip + 1;
        emit(if b goto 0);
        // goto 0 是因为转移目的地尚不可知, 暂记为0
        emit(goto 0)
      }
```

也可写为
```
B → b { B.T := ip;
        emit(if b goto 0);
        B.F := ip;
        emit(goto 0)
      }
```

对产生式 `B → i1 rop i2` 有:
```
B → i1 rop i2 { B.T := ip;
                emit(if i1 rop i2 goto 0);
                B.F := ip;
                emit(goto 0)
              }
```

##### 无条件转移语句的翻译

```
lable → i;
S → goto i;
```

1. 向前转移
   
   ```
   L:
   ...
   goto L;
   ```

   其翻译方法为 `S → goto L{emit(goto L)}`

2. 向后转移
   
   ```
   goto L;
   ...
   L:
   ```

   在向后转移的时候, 首先遇到 `goto L` 语句, 此时 L 未知, 只能将 L 填入符号表, 并标记未定义. 所以对 `goto L` 只能生成不确定的三地址语句 `goto 0`, 它的转移目标必须在 L 定义时再返填进去. 有可能有几个 goto 语句都转移到同一个未定义的 L, 所以必须记住所有的待返填的三地址语句, 用一个链表来保存.

   | 名字 | 类型 | ... | 是否定义 | 地址 |
   | ---- | ---- | --- | -------- | ---- |
   | ...  |      |     |          |      |
   | L    | 标号 |     | 否       | r    |
   |      |      |     |          |      |
   
   表中的 r 指向一个链表, 类似这样的格式 `r -> goto q -> goto p -> goto 0` 

   然后此处新引入了一个语义函数 `backpatch(r, ip)` , 用来把 r 为链首的链上的所有三地址语句的转移目标都填为 ip 的当前值.
   
##### 条件语句的翻译

简单起见, 考虑下面的产生式

```
S → if B then S1
S → if B then S1 else S2
```

对于 `S → if B then S1`

![](https://raw.githubusercontent.com/zgw0/blog/master/imgs/by1.png)

如上图所示, 整个语句翻译完成后 B.F 仍不能确定, 只能将它作为 S 的语义值 S.CHAIN 暂时保留下来. 如果 S<sub>1</sub> 本身也是控制语句, 它也有语义值 S<sub>1</sub>.CHAIN 未确定, 则 B.F 和 S<sub>1</sub>.CHAIN 应转到同一个地方, 因此要将他们链接起来, 链首地址记录在 S 的语义值 S.CHAIN 中, 这项工作由语义函数 `merge()` 完成.

`merge(P1, P2)` 把以 P<sub>1</sub> 和 P<sub>2</sub> 为首的两条链合并为一条链, 回送的函数值为合并后的链首 P<sub>2</sub>.

例子:
```
M → if B then { backpatch(B.T, ip);
                M.CHAIN = B.F }
N → M S1 else { q:=ip;   
                emit(goto 0);
                backpatch(M.CHAIN,ip);
                N.CHAIN = merge(S1.CHAIN , q) }
S → N S2      { S.CHAIN = merge(S2.CHAIN, N.CHAIN) }
```

##### while 语句的翻译

`S → while B do S1`

```
// 语义变量 W.CODE 记住 B 的第一个三元地址语句的编号
W → while      { W.CODE = ip; }
D → while B do { backpatch(B.T,ip);
                 D.CHAIN:=B.F;
                 D.CODE:=B.T }
S → D S1       { backpatch(S1.CHAIN,D.CODE);
                 emit(goto D.CODE);
                 S.CHAIN:=D.CHAIN }
```

##### for 语句的翻译
`S → for i:=E1 step E2 until E3 do S1`

`S → for i:=1 to N do S1`

![](https://raw.githubusercontent.com/zgw0/blog/master/imgs/by_for.png)

翻译方案

```
原文法
  S → for i:=1 to N do S1
改写为
  F → for i:=1 to N do
  S → F S1
```

F具有三个语义值

1. F.CHAIN:记录F+2
1. F.place:记录i在符号表入口
1. F.again:记录F+1

```
F → for i:=1 to N do { F.place:=entry(i)；
                       emit(i:=1);
                       F.again:=ip;                 //F+1 
                       emit(if entry(i) <= N goto F.again+2);
                       F.CHAIN:=ip;                 //F+2
                       emit(goto 0); }
S → F S1             { backpatch(S1.CHAIN,ip);
                       emit (i = i + 1);
                       emit(goto F.again);
                       S.CHAIN:=F.CHAIN }
```

##### 过程调用的翻译

翻译工作将控制转移到某个子程序转移之前必须用某种方法将 **实参** 、 **参数个数** 和 **返回地址** 等信息传递给子程序，以便这些信息在进入子程序之后被引用。

## 代码优化和目标代码生成
### 优化的目标和意义
#### 优化的定义
**优化**是一种等价的，有效的程序变换

等价——不改变程序运行结果

有效——时空效率要高

#### 不同阶段的优化

1. 源程序阶段的优化
   
   优化DS和算法
2. 编译优化
         
   中间代码(局部优化和全局优化)和目标代码优化

   局部优化：在基本块内的优化

   全局优化：超越基本块，基本块之间的优化

### 局部优化
#### 基本块的划分
为了实现局部优化, 首先必须在程序中划分出基本块. 按照基本块的定义, 首先必须找出程序中的入口语句和出口语句, 然后才可以划分出基本块.

入口语句:
- 程序的第一个语句
- 能由转向语句(条件转移语句或无条件转移语句)转移到的语句
- 紧跟在条件专题语句之后的语句

出口语句:
- 转向语句
- 停止语句

划分基本块的算法:

1. 寻找入口语句

   - 程序的第一条语句

   - 由转向语句转移到的语句

   - 紧跟在条件转向语句后的那个语句

2. 确定基本块

     ```
     入口语句
      ...
     入口语句

     入口语句
     ...
     转向语句

     入口语句
     ...
     停语句
     ```
3. 删除未被划入基本块的语句

![](https://s2.ax1x.com/2019/06/11/VgVEiq.png)

#### 程序流图

程序流图(Program Flow Graph)是程序结构的图形表示. 一个基本块是程序流程图的一个结点, 一个程序的所有基本块是程序流图的结点集(记为 N ). 包含程序第一个语句的基本块记为首结点n<sub>0</sub>

所以, 程序流图 G 可定义为:

<code>G = (N, E, n<sub>0</sub>)</code>

程序流图构造的方式
设Bi , Bj ∈ N ，若满足下列条件之一，则Bi -> Bj

- Bj 紧跟在Bi 之后，且Bi 的出口语句不是无条件转向或停止语句

- Bi 的出口语句为转向语句，其转向点恰为Bj 的入口语句

#### 基本块内的优化
1. 合并已知量
2. 删除公共子表达式
3. 删除无用赋值
4. 删除死代码

![](https://s2.ax1x.com/2019/06/11/Vg8Fw6.png)

### 全局优化
要进行全局优化，必须对程序的数据流进行分析，这是比较复杂的。所以只讨论对循环进行的优化。循环优化对提高目标代码的有效性特别有意义。

为了找出循环，必须对程序中的控制流进行分析。**控制流分析**也是程序中数据流分析的基础，它是优化的重要工具。

**循环的定义**: 程序流图中,有唯一入口结点的强连通子图。

#### 循环的查找
首先引入回边的概念. 流图G=(N，E，n<sub>0</sub>)中的有向边 n -> d 如果 d 是 n 的必经结点,则称 n -> d 为流图的一条回边。


若 n -> d 是 G=(N,E, n<sub>0</sub>) 的一条回边，M 是流图中有通路到达 n 而该通路不经过 d 的结点集,则 Loop= {n, d}∪M 组成了 G 的一个子图称为由回边 n -> d 组成的自然循环。

可以证明, LOOP 就是 G 的一个具有唯一入口结点的强连通子图. 

#### 循环的优化

1. 代码外提
2. 强度削弱
3. 变换循环控制条件，复写传播，合并已知量
4. 删除归纳变量

### 并行优化

<details>
<h3>数据的依赖关系分析</h3>
<ol>
  <li> 常见的数据依赖关系</li>
    <ul>
      <li>真相关</li>
      <li>反相关</li>
      <li>输出相关</li>
    </ul>
  <li> 数据依赖图的构造</li>
  <li> 循环中的数据依赖关系</li>
  <li> 依赖关系的 GCD 分析方法</li>
</ol>
<h3>向量化代码生成</h3>
<h3>反相关与输出相关的消除</h3>
<h3>标量扩张</h3>
<h3>循环条块化</h3>
</details>

### 目标代码的生成

1. 目标代码生成的任务: 将中间代码翻译成 **等价、有效** 的目标代码

2. 目标代码生成器的输入: 中间代码，符号表
3. 代码生成器的输出 目标代码： 绝对机器代码 可重定位代码 汇编码
4. 抽象机的(汇编)指令形式

   op 目的，源  
   
   或   

   op  源，目的    (对MOV型指令)
   
   源可以是内存单元、寄存器或常数  
   目的可以是内存单元、寄存器
5. 简单的代码生成方法
    
   `p:  t:=  y  op  z`  翻译为

   ```
   m:   MOV y , Ri
   m+1: op  Ri, z
   ```
   为 y 分配寄存器的方法
   - y 本身占有寄存器 R<sub>i</sub> , 且y在p点后不再被引用，则仅需 `op Ri, z`
   - 有空余的可用寄存器 R<sub>i</sub>, 分配寄存器R<sub>i</sub>给y, 然后生成2指令.
   - 寄存器均被占用, 从被占用的寄存器中选择一个 R<sub>i</sub>, 需要先保存R<sub>i</sub>的内容, 然后生成2指令

   在第三种情况下选择 R<sub>i</sub> 的标准:

   最好选择占用 R<sub>i</sub> 的变量在主存中已有副本的(少执行一次MOV)；

   或者在 p 点后该变量不再被引用的；

   或者在离 p 点最远处才被引用的。

6. 循环中的寄存器分配
   ```
   寄存器型     op Ri，Rj       执行代价为1
   直接地址型   op  Ri，M        执行代价为2
   变址型       op Ri，C(Rj)    执行代价为2
   间址型       op Ri, *Rj      执行代价为2
               op Ri, *M       执行代价为3
               op Ri, *C(Rj)   执行代价为3
   ```


## 补充

静态作用域和动态作用域:

> 在计算机程序设计中，作用域（scope，或译作有效范围）是名字（name）与实体（entity）的绑定（binding）保持有效的那部分计算机程序。不同的编程语言可能有不同的作用域和名字解析。而同一语言内也可能存在多种作用域，随实体的类型变化而不同。作用域类别影响变量的绑定方式，根据语言使用静态作用域还是动态作用域变量的取值可能会有不同的结果。


静态作用域(又叫做词法作用域)指的是一段代码，在它执行之前就已经确定了它的作用域，简单来说就是在执行之前就确定了它可以应用哪些地方的作用域(变量)。

JavaScript采用的是词法作用域即静态作用域；

```
//  静态作用域：
var a = 10;

function fn() {
    var b = 1;
    console.log(a + b);
}

fn(); // 11
```

在创建fn函数时的时候就已经确定了它可以作用哪些变量，如果函数fn里面有变量a就直接操作变量a, 如果没有就往上一级查找，这就是静态作用域

```js
// 如果js采用的时动态作用域，那么foo在bar中调用，就会先在bar中查询a,输出为3。
function foo() {
    console.log(a);
}

function bar() {
    var a = 3;
    foo();
}

var a = 2;
bar(); // 2;
```

bar 调用，bar里面foo被调用，foo函数需要查找变量a，由于JavaScript是词法作用域(即静态作用域)，foo被解析时在全局作用域. 

所以只能在全局作用域中找a,输出结果为2，而非bar作用域中的a。如果js采用的时动态作用域，那么foo在bar中调用，就会先在bar中查询a,输出为3。

```js
const foo = function () {
    console.log(a);
}

const bar = function () {
    var a = 3;
    foo();
}

var a = 2;
bar(); // 2;
```

```js
// 两段代码都会打印：local scope
var scope = "global scope";
function checkscope(){
    var scope = "local scope";
    function f(){
        return scope;
    }
    return f();
}
checkscope();
var scope = "global scope";
function checkscope(){
    var scope = "local scope";
    function f(){
        return scope;
    }
    return f;
}
checkscope()();
```