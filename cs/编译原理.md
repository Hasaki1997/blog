## 编译概述

![](https://raw.githubusercontent.com/zgw0/blog/master/imgs/by_main.png)

1. 词法分析(词法分析器是一个有限状态自动机)
   
   根据词法规则识别出单词符号。基本字、标识符、字面常量、运算符和界符

2. 语法分析(语法分析器是一个下推自动机)

   根据语法规则，识别各类语法单位. 如表达式、语句、程序单元和程序等, 并进行语法检查

3. 语义分析与中间代码生成

   根据语义规则，对语法正确的语法单位进行翻译, 可以直接生成目标程序, 但目标程序的执行效率低. 因此，生成中间代码。

   大多数编译器采用中间代码来描述源程序的语义。这种中间语言对应某种抽象机, 结构简单，语义明确，易于翻译成目标代码，同时也便于优化和移植。

1. 中间代码优化

   对中间代码进行等价变换，提高代码的时空效率。语义分析产生的中间代码不依赖于实际机器，易于实现一些等价变换，使生成的目标程序占用空间更少，执行更快。

2. 目标代码生成

   根据优化后的中间代码及有关信息，可生成较为有效的目标代码：目标机的机器语言程序或汇编语言程序, 若生成的是汇编语言程序，还需由将其汇编成机器语言程序。

编译的每个步骤都需要进行 **符号表管理** 和 **出错处理**

## 词法分析

1. 删除编辑用字符，如控制符:LF(换行)、CR(回车)、FF(换页)等。
2. 删除注释。
3. 合并多个空白字符 为单个空白字符。
4. 组合多个独立文件中的源程序。
5. 展开宏定义 
6. 条件编译的选择等。

我用 c++ 实现的一个词法分析器: [lexical_analysis.cpp](https://github.com/zgw0/experiment/blob/master/compile/lexical_analysis.cpp)

## 自上而下的语法分析

### 引言
编译理论中，语法分析是对高级语言的语法单位的结构进行分析。

语法单位结构可以用**上下文无关文法**来描述。

**下推自动机**可用于识别上下文无关文法所描述的语法单位。

上下文无关文法及下推自动机是语法分析的**理论基础**。

> 自上而下的语法分析
> 
> 对无关文法G=(VT，VN，S，P)及符号串w，判断w是否是文法G的一个合法句子
> 
> 即 S=>*w
>
> 或者从根结点S开始，能否构造一棵语法树，使得该语法树的叶结点自左至右的连接正好是w

自上而下的语法分析可分为不确定和确定的两类。
- 回溯分析法是不确定的分析方法。
- 递归下降分析法和预测分析法属于确定的分析方法。

### 回溯分析法
#### 回溯产生的原因
1. 公共左因子
1. 左递归
1. ε产生式

左递归分为直接左递归和间接左递归。
- 直接左递归经过一次推导就可以看出文法存在左递归，如P→Pa｜b。
- 间接左递归侧需多次推导才可以看出文法存在左递归，如文法：S→Qc｜c，Q→Rb｜b，R→Sa｜a有S =>Qc =>Rbc =>Sabc

回溯分析法是一种不确定的方法。使用试探的方法穷举每一种可能，当分析不成功时，则回退到适当位置再重新试探其余可能的推导。穷尽所有可能的推导，仍不成功才能确认输入串不是该文法的句子

#### 回溯分析法主要缺陷

1. 选择候选式进行推导是盲目的
1. 若文法存在左递归，语法分析还可能产生无限循环。
1. 引起时间和空间的大量消耗。
1. 无法指出语法错误的确切位置

#### 消除回溯的方法

为了消除回溯，对任何一个非终结符和当前的待匹配符号，期望要么只有一个侯选式可用要么没有侯选式可用

1. 提取公因子
    ```
    S→xAy
    A→ab│a   
    ```

    提取公共左因子，得

    ```
    S→xAy
    A→aB
    B→b│ε
    ```

2. 消除左递归

   直接左递归的消除:

   设文法 G 含有直接左递归的产生式为:

   <img src="https://camo.githubusercontent.com/4e2518cc0e21dcbe972d5ca6a86c475c9a675258/68747470733a2f2f6c617465782e636f6465636f67732e636f6d2f7376672e6c617465783f412532305c72696768746172726f77253230415c616c7068615f317c415c616c7068615f327c2e2e2e7c415c616c7068615f6e7c5c62657461" />

   消除左递归后的产生式为:

   <img src="https://camo.githubusercontent.com/2215e0633453058d733b6c5e90a260f9bdc208e2/68747470733a2f2f6c617465782e636f6465636f67732e636f6d2f7376672e6c617465783f412532305c72696768746172726f772532305c62657461253230415e253237" />
   <br />
   <img src="https://camo.githubusercontent.com/035f710d656addce7834623f555ec67d52291241/68747470733a2f2f6c617465782e636f6465636f67732e636f6d2f7376672e6c617465783f412532305e7b2532377d2532305c72696768746172726f772532305c616c7068615f31415e7b2532377d7c5c616c7068615f32415e7b2532377d7c2e2e2e7c5c616c7068615f6e415e7b2532377d7c2532305c766172657073696c6f6e" />

   间接左递归的消除

   
   `A → +Aα` , 利用算法进行。

   1. 将文法G的所有非终结符按任一给定的顺序排列为
    A1，A2，…，An
   2. 消除可能的左递归


      op = 把形如 A<sub>i</sub> → A<sub>j</sub>α 的产生式改写为 A<sub>i</sub> → δ<sub>1</sub> α|δ<sub>2</sub> α|…|δ<sub>k</sub> α,消除Ai产生式可能的直接左递归
      ```
      for i:=1 to n do
      begin
        for j:=1 to i-1 do        
         op
      end
      ```

    3. 化简, 删除多余产生式.

### 递归下降分析法

在文法 G 中，如果没有任何公共左因子, 没有任何左递归, 则有可能构造出不带回溯的分析程序

我用 c++ 实现的一个基于递归下降分析法的语法分析器: [syntax_analysis.cpp](https://github.com/zgw0/experiment/blob/master/compile/syntax_analysis.cpp)

在文法G中，如果没有任何公共左因子,没有任何左递归也可能构造不出递归下降分析器, 如 `A→Ba│Cb`

### 预测分析法

将递归下降分析方法进行变化，可以得到更有效的方法—预测分析法

预测分析法是一种表驱动的方法, **下推栈、预测分析表和控制程序** 是下推自动机的一种实现模型。

预测出每个侯选式的匹配作用, 指导推导过程的进行。在输入串前、后加上#做标记

预测分析法的关键是预测分析表, 对于不同的上下文无关文法, 预测分析过程是相同的，, 只是预测分析表的内容不相同

#### 预测分析表的构建
1. FIRST 集

FIRST(α) 是由 α 的所有可能推导的开头终结符及可能的 ε 组成的集合.

2. FOLLOW 集

FOLLOW(A) 是在文法的所有句型中紧跟在 A 后的终结符及可能的 # 组成的集合.

3. 构造预测分析表的方法

初始，栈中存放栈底符#和开始符S

输入指针指向输入串ω的第一个符号

某一时刻：

下推栈的栈顶符号x（x∈V∪{#} ）


当前的输入符号a   （a∈VT∪{#}）

分析器的动作有下列四种选择：

```
(1) x=a=#
符号串和栈均已为空;
则输入串ω是该文法的一个合法句子
分析过程结束。
(2) x=a≠#
栈顶符号与输入符号匹配
则x出栈，输入指针指向下一个符号
这一次匹配成功，继续下一次匹配（转步骤0）。
(3) x为终结符，但x ≠ a   
栈顶符号与输入符号不匹配
则调用出错处理程序error( )
(4) x为非终结符，则查分析表。
若M[x，a]中存放 x→α
则x出栈，将α串逆序压入栈中(α的 第1个符号处于栈顶位置), 转步骤0。
若M[x，a]中为出错标志，则调用出错处理程序error( )。
```

## 自下而上的语法分析



## 语义分析和中间代码生成
### 语义分析概论
#### 语义分析的任务
1. 语义检查
   
   主要进行一致性检查和越界检查

   主要有: 类型检查, 控制流检查(用以保证控制语句有合法的转向点:如不允许goto语句转入case语句流;break语句需要在switch或循环语句)和一致性检查(数组维数是否正确;变量是否已经定义；变量是否重名；case常量不能相同等)

2. 语义处理
   
   说明语句: 登记信息到符号表

   执行语句: 生成中间代码

#### 语法制导翻译

语法制导翻译: 在语法分析的过程中, 根据每个产生式所对应的语义子程序(语义动作)进行翻译(生成中间代码)的方法.

语义子程序(语义动作): 完成语义检查和语义处理. 每一个语句(或语法单位)对应一组语义子程序, 语义子程序实际上描述该语法单位的语义规则, 它的核心任务是生成中间代码.

在描述语义动作(语义子程序)时, 需要给每个文法符号 X 不同的语义值, 如'类型', '种属', '地址', '代码'等. 我们用记号 X.TYPE, X.CAT 或 X.VAL 来表示这些值.

语义子程序不是计值程序, 而是某种中间代码生成**工具**, 语法制导翻译既可以用来生成各种中间代码, 也可以用来直接产生目标指令, 甚至可以用来对输入符号串解释执行.
### 中间代码

中间代码有很多种形式: 三地址形式(四元式), 后缀式, 语法树等, 三地址形式(x = y op z)是最常见的

三地址语句常见形式:

- 二元运算类赋值语句 `x:=y op z`
- 一元运算类赋值语句 `x:=op z`
- 复制类赋值语句 `x:=y`
- 无条件转移语句 `goto L`

### 语义变量和语义函数
编译器在语义分析时, 要用到一些工作单元和子程序, 称它们为语义变量和语义函数

常用的有:

1. i.NAME : 语义变量, 和终结符 i 相关联, 表示 i 对应的变量名.
2. E.PLACE : 语义变量, 和非终结符 E 相关联, 表示与 E 对应的变量在符号表中的位置(若该变量是一个普通变量)或证书编码(若该变量是一个临时变量).
3. newtemp() : 语义函数, 产生一个新的临时变量, 并返回其整数编码 i. 在后面的使用中, 将该临时变量表示为 t<sub>i</sub>.
4. entry(i) : 语义函数, 为名字为 i 的变量查符号表.
5. emit(RESULT, OPD1, oper, OPD2)或emit(RESULT, oper, OPD) : 语义函数, 根据指定的参数产生一个新的三地址语句, 并传输到输出指针 ip 指向的位置, 然后 ip 自动加1, 指向下一个位置
6. error() : 语义函数, 表示出错.

### 翻译

#### 变量语句的翻译

变量说明语句语义分析的工作不需要翻译为中间代码,仅登记信息将被说明的变量的类型及相对存储位置(相对地址)记入符号表(变量表)中.

语义变量及过程

1. offset : 相对位移量,全局变量,初值0
2. T.type : 数据类型
3. T.width : 数据宽度（变量需要的内存单元字节数）
4. enter : 语义过程,根据变量名，将对应的类型和相对地址记入符号表中。
5. 
#### 简单赋值语句的翻译
假设某赋值语句可以用下列文法来描述:

```
A → i:=E
E → i
E → (E1)
E → -E1 
E → E1 op E2
```

翻译方案:

```
A → i:=E      { emit (entry(i), :=, E.PLACE) }
E → i         { E.PLACE:=entry(i) }
E → (E1)      { E.PLACE:= E1.PLACE  }
// 产生式 E → -E1 中的 - 表示一元运算符 uminus
E → -E1       { E.PLACE:=newtemp( ); 
                emit(E.PLACE, uminus, E1.PLACE) }
E → E1 op E2  { E.PLACE:=newtemp( );
                emit(E.PLACE, E1.PLACE, op, E2.PLACE) }
```

#### 控制语句的翻译
##### 布尔表达式的翻译

```
B → b          // b 为true, false 或逻辑变量
B → i1 rop i2
```

布尔表达式可翻译成两个表示转移的三地址语句: 一个用于转移到为真的地方, 称为真出口, 记为 B.T; 另一个用于转移到为假的地方, 称为假出口, 记为 B.F.

由此可以写出上述两个产生式的语义子程序

对产生式 `B → b` 有:

```
B → b { B.T := ip;
        B.F := ip + 1;
        emit(if b goto 0);
        // goto 0 是因为转移目的地尚不可知, 暂记为0
        emit(goto 0)
      }
```

也可写为
```
B → b { B.T := ip;
        emit(if b goto 0);
        B.F := ip;
        emit(goto 0)
      }
```

对产生式 `B → i1 rop i2` 有:
```
B → i1 rop i2 { B.T := ip;
                emit(if i1 rop i2 goto 0);
                B.F := ip;
                emit(goto 0)
              }
```

##### 无条件转移语句的翻译

```
lable → i;
S → goto i;
```

1. 向前转移
   
   ```
   L:
   ...
   goto L;
   ```

   其翻译方法为 `S → goto L{emit(goto L)}`

2. 向后转移
   
   ```
   goto L;
   ...
   L:
   ```

   在向后转移的时候, 首先遇到 `goto L` 语句, 此时 L 未知, 只能将 L 填入符号表, 并标记未定义. 所以对 `goto L` 只能生成不确定的三地址语句 `goto 0`, 它的转移目标必须在 L 定义时再返填进去. 有可能有几个 goto 语句都转移到同一个未定义的 L, 所以必须记住所有的待返填的三地址语句, 用一个链表来保存.

   | 名字 | 类型 | ... | 是否定义 | 地址 |
   | ---- | ---- | --- | -------- | ---- |
   | ...  |      |     |          |      |
   | L    | 标号 |     | 否       | r    |
   |      |      |     |          |      |
   
   表中的 r 指向一个链表, 类似这样的格式 `r → goto q → goto p → goto 0` 

   然后此处新引入了一个语义函数 `backpatch(r, ip)` , 用来把 r 为链首的链上的所有三地址语句的转移目标都填为 ip 的当前值.
   
##### 条件语句的翻译

简单起见, 考虑下面的产生式

```
S → if B then S1
S → if B then S1 else S2
```

对于 `S → if B then S1`

![](https://raw.githubusercontent.com/zgw0/blog/master/imgs/by1.png)

如上图所示, 整个语句翻译完成后 B.F 仍不能确定, 只能将它作为 S 的语义值 S.CHAIN 暂时保留下来. 如果 S<sub>1</sub> 本身也是控制语句, 它也有语义值 S<sub>1</sub>.CHAIN 未确定, 则 B.F 和 S<sub>1</sub>.CHAIN 应转到同一个地方, 因此要将他们链接起来, 链首地址记录在 S 的语义值 S.CHAIN 中, 这项工作由语义函数 `merge()` 完成.

`merge(P1, P2)` 把以 P<sub>1</sub> 和 P<sub>2</sub> 为首的两条链合并为一条链, 回送的函数值为合并后的链首 P<sub>2</sub>.

例子:
```
M → if B then { backpatch(B.T, ip);
                M.CHAIN = B.F }
N → M S1 else { q:=ip;   
                emit(goto 0);
                backpatch(M.CHAIN,ip);
                N.CHAIN = merge(S1.CHAIN , q) }
S → N S2      { S.CHAIN = merge(S2.CHAIN, N.CHAIN) }
```

##### while 语句的翻译

`S → while B do S1`

```
// 语义变量 W.CODE 记住 B 的第一个三元地址语句的编号
W → while      { W.CODE = ip; }
D → while B do { backpatch(B.T,ip);
                 D.CHAIN:=B.F;
                 D.CODE:=B.T }
S → D S1       { backpatch(S1.CHAIN,D.CODE);
                 emit(goto D.CODE);
                 S.CHAIN:=D.CHAIN }
```

`S → do S while B`

```
D → do        { D.Code := ip;}
W → D S while { backpatch(S.Chain,ip); W.Code=D.Code; }
S → W B       { backpatch(B.T,W.Code); S.Chain=B.F; }
```

##### for 语句的翻译
`S → for i:=E1 step E2 until E3 do S1`

`S → for i:=1 to N do S1`

![](https://raw.githubusercontent.com/zgw0/blog/master/imgs/by_for.png)

翻译方案

```
原文法
  S → for i:=1 to N do S1
改写为
  F → for i:=1 to N do
  S → F S1
```

F具有三个语义值

1. F.CHAIN:记录F+2
1. F.place:记录i在符号表入口
1. F.again:记录F+1

```
F → for i:=1 to N do { F.place:=entry(i)；
                       emit(i:=1);
                       F.again:=ip;                 //F+1 
                       emit(if entry(i) <= N goto F.again+2);
                       F.CHAIN:=ip;                 //F+2
                       emit(goto 0); }
S → F S1             { backpatch(S1.CHAIN,ip);
                       emit (i = i + 1);
                       emit(goto F.again);
                       S.CHAIN:=F.CHAIN }
```

##### 过程调用的翻译

翻译工作将控制转移到某个子程序转移之前必须用某种方法将 **实参** 、 **参数个数** 和 **返回地址** 等信息传递给子程序，以便这些信息在进入子程序之后被引用。


## 代码优化和目标代码生成
### 优化的目标和意义
#### 优化的定义
**优化**是一种等价的，有效的程序变换

等价——不改变程序运行结果

有效——时空效率要高

#### 不同阶段的优化

1. 源程序阶段的优化
   
   优化DS和算法
2. 编译优化
         
   中间代码(局部优化和全局优化)和目标代码优化

   局部优化：在基本块内的优化

   全局优化：超越基本块，基本块之间的优化

### 局部优化
#### 基本块的划分
为了实现局部优化, 首先必须在程序中划分出基本块. 按照基本块的定义, 首先必须找出程序中的入口语句和出口语句, 然后才可以划分出基本块.

入口语句:
- 程序的第一个语句
- 能由转向语句(条件转移语句或无条件转移语句)转移到的语句
- 紧跟在条件专题语句之后的语句

出口语句:
- 转向语句
- 停止语句

划分基本块的算法:

1. 寻找入口语句

   - 程序的第一条语句

   - 由转向语句转移到的语句

   - 紧跟在条件转向语句后的那个语句

2. 确定基本块

     ```
     入口语句
      ...
     入口语句

     入口语句
     ...
     转向语句

     入口语句
     ...
     停语句
     ```
3. 删除未被划入基本块的语句

![](https://s2.ax1x.com/2019/06/11/VgVEiq.png)

#### 程序流图

程序流图(Program Flow Graph)是程序结构的图形表示. 一个基本块是程序流程图的一个结点, 一个程序的所有基本块是程序流图的结点集(记为 N ). 包含程序第一个语句的基本块记为首结点n<sub>0</sub>

所以, 程序流图 G 可定义为:

<code>G = (N, E, n<sub>0</sub>)</code>

程序流图构造的方式
设Bi , Bj ∈ N ，若满足下列条件之一，则Bi → Bj

- Bj 紧跟在Bi 之后，且Bi 的出口语句不是无条件转向或停止语句

- Bi 的出口语句为转向语句，其转向点恰为Bj 的入口语句

#### 基本块内的优化
1. 合并已知量
2. 删除公共子表达式
3. 删除无用赋值
4. 删除死代码

![](https://s2.ax1x.com/2019/06/11/Vg8Fw6.png)

### 全局优化
要进行全局优化，必须对程序的数据流进行分析，这是比较复杂的。所以只讨论对循环进行的优化。循环优化对提高目标代码的有效性特别有意义。

为了找出循环，必须对程序中的控制流进行分析。**控制流分析**也是程序中数据流分析的基础，它是优化的重要工具。

**循环的定义**: 程序流图中,有唯一入口结点的强连通子图。

#### 循环的查找
首先引入回边的概念. 流图G=(N，E，n<sub>0</sub>)中的有向边 n → d 如果 d 是 n 的必经结点,则称 n → d 为流图的一条回边。


若 n → d 是 G=(N,E, n<sub>0</sub>) 的一条回边，M 是流图中有通路到达 n 而该通路不经过 d 的结点集,则 Loop= {n, d}∪M 组成了 G 的一个子图称为由回边 n → d 组成的自然循环。

可以证明, LOOP 就是 G 的一个具有唯一入口结点的强连通子图. 

#### 循环的优化

1. 代码外提
2. 强度削弱
3. 变换循环控制条件，复写传播，合并已知量
4. 删除归纳变量

### 并行优化

<details>
<h3>数据的依赖关系分析</h3>
<ol>
  <li> 常见的数据依赖关系</li>
    <ul>
      <li>真相关</li>
      <li>反相关</li>
      <li>输出相关</li>
    </ul>
  <li> 数据依赖图的构造</li>
  <li> 循环中的数据依赖关系</li>
  <li> 依赖关系的 GCD 分析方法</li>
</ol>
<h3>向量化代码生成</h3>
<h3>反相关与输出相关的消除</h3>
<h3>标量扩张</h3>
<h3>循环条块化</h3>
</details>

### 目标代码的生成

1. 目标代码生成的任务: 将中间代码翻译成 **等价、有效** 的目标代码

2. 目标代码生成器的输入: 中间代码，符号表
3. 代码生成器的输出 目标代码： 绝对机器代码 可重定位代码 汇编码
4. 抽象机的(汇编)指令形式

   op 目的，源  
   
   或   

   op  源，目的    (对MOV型指令)
   
   源可以是内存单元、寄存器或常数  
   目的可以是内存单元、寄存器
5. 简单的代码生成方法
    
   `p:  t:=  y  op  z`  翻译为

   ```
   m:   MOV y , Ri
   m+1: op  Ri, z
   ```
   为 y 分配寄存器的方法
   - y 本身占有寄存器 R<sub>i</sub> , 且y在p点后不再被引用，则仅需 `op Ri, z`
   - 有空余的可用寄存器 R<sub>i</sub>, 分配寄存器R<sub>i</sub>给y, 然后生成2指令.
   - 寄存器均被占用, 从被占用的寄存器中选择一个 R<sub>i</sub>, 需要先保存R<sub>i</sub>的内容, 然后生成2指令

   在第三种情况下选择 R<sub>i</sub> 的标准:

   最好选择占用 R<sub>i</sub> 的变量在主存中已有副本的(少执行一次MOV)；

   或者在 p 点后该变量不再被引用的；

   或者在离 p 点最远处才被引用的。

6. 循环中的寄存器分配
   ```
   寄存器型     op Ri，Rj       执行代价为1
   直接地址型   op  Ri，M        执行代价为2
   变址型       op Ri，C(Rj)    执行代价为2
   间址型       op Ri, *Rj      执行代价为2
               op Ri, *M       执行代价为3
               op Ri, *C(Rj)   执行代价为3
   ```


## 补充
### A. 静态作用域和动态作用域:

> 在计算机程序设计中，作用域（scope，或译作有效范围）是名字（name）与实体（entity）的绑定（binding）保持有效的那部分计算机程序。不同的编程语言可能有不同的作用域和名字解析。而同一语言内也可能存在多种作用域，随实体的类型变化而不同。作用域类别影响变量的绑定方式，根据语言使用静态作用域还是动态作用域变量的取值可能会有不同的结果。


静态作用域(又叫做词法作用域)指的是一段代码，在它执行之前就已经确定了它的作用域，简单来说就是在执行之前就确定了它可以应用哪些地方的作用域(变量)。

JavaScript采用的是词法作用域即静态作用域；

```
//  静态作用域：
var a = 10;

function fn() {
    var b = 1;
    console.log(a + b);
}

fn(); // 11
```

在创建fn函数时的时候就已经确定了它可以作用哪些变量，如果函数fn里面有变量a就直接操作变量a, 如果没有就往上一级查找，这就是静态作用域

```js
// 如果js采用的时动态作用域，那么foo在bar中调用，就会先在bar中查询a,输出为3。
function foo() {
    console.log(a);
}

function bar() {
    var a = 3;
    foo();
}

var a = 2;
bar(); // 2;
```

bar 调用，bar里面foo被调用，foo函数需要查找变量a，由于JavaScript是词法作用域(即静态作用域)，foo被解析时在全局作用域. 

所以只能在全局作用域中找a,输出结果为2，而非bar作用域中的a。如果js采用的时动态作用域，那么foo在bar中调用，就会先在bar中查询a,输出为3。

```js
const foo = function () {
    console.log(a);
}

const bar = function () {
    var a = 3;
    foo();
}

var a = 2;
bar(); // 2;
```

```js
// 两段代码都会打印：local scope
var scope = "global scope";
function checkscope(){
    var scope = "local scope";
    function f(){
        return scope;
    }
    return f();
}
checkscope();
var scope = "global scope";
function checkscope(){
    var scope = "local scope";
    function f(){
        return scope;
    }
    return f;
}
checkscope()();
```

### B. Lex 和 Yacc
Lex 代表 Lexical Analyzar。Yacc 代表 Yet Another Compiler Compiler。

#### Lex

Lex 自动地把输入串词法结构的正则表达式及其相应的动作转换成一个宿主语言的程序, 即词法分析程序, 他有一个固定的名字 yylex. yylex 将识别出输入串中的词形, 并且在识别出某词形时完成指定的动作.

Lex 编程可以分为三步：

1. 以 Lex 可以理解的格式指定模式相关的动作。
1. 在这一文件上运行 Lex，生成扫描器的 C 代码。
1. 编译和链接 C 代码，生成可执行的扫描器。

一个 Lex 程序分为三个段：定义段, 规则段, 用户子程序段.
#### Yacc

Yacc是一种工具，将任何一种编程语言的所有语法翻译成针对此种语言的 Yacc 语 法解析器。它用巴科斯范式(BNF, Backus Naur Form)来书写。按照惯例，Yacc 文件有 .y 后缀。