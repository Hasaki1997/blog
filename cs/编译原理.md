## 语义分析和中间代码生成
### 语义分析概论
#### 语义分析的任务
1. 语义检查
   
   主要进行一致性检查和越界检查

   主要有: 类型检查, 控制流检查(用以保证控制语句有合法的转向点:如不允许goto语句转入case语句流;break语句需要在switch或循环语句)和一致性检查(数组维数是否正确;变量是否已经定义；变量是否重名；case常量不能相同等)

2. 语义处理
   
   说明语句: 登记信息到符号表

   执行语句: 生成中间代码

#### 语法制导翻译

语法制导翻译: 在语法分析的过程中, 根据每个产生式所对应的语义子程序(语义动作)进行翻译(生成中间代码)的方法.

语义子程序(语义动作): 完成语义检查和语义处理. 每一个语句(或语法单位)对应一组语义子程序, 语义子程序实际上描述该语法单位的语义规则, 它的核心任务是生成中间代码.

在描述语义动作(语义子程序)时, 需要给每个文法符号 X 不同的语义值, 如'类型', '种属', '地址', '代码'等. 我们用记号 X.TYPE, X.CAT 或 X.VAL 来表示这些值.

语义子程序不是计值程序, 而是某种中间代码生成**工具**, 语法制导翻译既可以用来生成各种中间代码, 也可以用来直接产生目标指令, 甚至可以用来对输入符号串解释执行.
### 中间代码

中间代码有很多种形式: 三地址形式(四元式), 后缀式, 语法树等, 三地址形式(x = y op z)是最常见的

三地址语句常见形式:

- 二元运算类赋值语句 `x:=y op z`
- 一元运算类赋值语句 `x:=op z`
- 复制类赋值语句 `x:=y`
- 无条件转移语句 `goto L`

### 语义变量和语义函数
编译器在语义分析时, 要用到一些工作单元和子程序, 称它们为语义变量和语义函数

常用的有:

1. i.NAME : 语义变量, 和终结符 i 相关联, 表示 i 对应的变量名.
2. E.PLACE : 语义变量, 和非终结符 E 相关联, 表示与 E 对应的变量在符号表中的位置(若该变量是一个普通变量)或证书编码(若该变量是一个临时变量).
3. newtemp() : 语义函数, 产生一个新的临时变量, 并返回其整数编码 i. 在后面的使用中, 将该临时变量表示为 t<sub>i</sub>.
4. entry(i) : 语义函数, 为名字为 i 的变量查符号表.
5. emit(RESULT, OPD1, oper, OPD2)或emit(RESULT, oper, OPD) : 语义函数, 根据指定的参数产生一个新的三地址语句, 并传输到输出指针 ip 指向的位置, 然后 ip 自动加1, 指向下一个位置
6. error() : 语义函数, 表示出错.

### 翻译

#### 变量语句的翻译

变量说明语句语义分析的工作不需要翻译为中间代码,仅登记信息将被说明的变量的类型及相对存储位置(相对地址)记入符号表(变量表)中.

语义变量及过程

1. offset : 相对位移量,全局变量,初值0
2. T.type : 数据类型
3. T.width : 数据宽度（变量需要的内存单元字节数）
4. enter : 语义过程,根据变量名，将对应的类型和相对地址记入符号表中。
5. 
#### 简单赋值语句的翻译
假设某赋值语句可以用下列文法来描述:

```
A → i:=E
E → i
E → (E1)
E → -E1 
E → E1 op E2
```

翻译方案:

```
A → i:=E      { emit (entry(i), :=, E.PLACE) }
E → i         { E.PLACE:=entry(i) }
E → (E1)      { E.PLACE:= E1.PLACE  }
// 产生式 E → -E1 中的 - 表示一元运算符 uminus
E → -E1       { E.PLACE:=newtemp( ); 
                emit(E.PLACE, uminus, E1.PLACE) }
E → E1 op E2  { E.PLACE:=newtemp( );
                emit(E.PLACE, E1.PLACE, op, E2.PLACE) }
```

#### 控制语句的翻译
##### 布尔表达式的翻译

```
B → b          // b 为true, false 或逻辑变量
B → i1 rop i2
```

布尔表达式可翻译成两个表示转移的三地址语句: 一个用于转移到为真的地方, 称为真出口, 记为 B.T; 另一个用于转移到为假的地方, 称为假出口, 记为 B.F.

由此可以写出上述两个产生式的语义子程序

对产生式 `B → b` 有:

```
B → b { B.T := ip;
        B.F := ip + 1;
        emit(if b goto 0);
        // goto 0 是因为转移目的地尚不可知, 暂记为0
        emit(goto 0)
      }
```

也可写为
```
B → b { B.T := ip;
        emit(if b goto 0);
        B.F := ip;
        emit(goto 0)
      }
```

对产生式 `B → i1 rop i2` 有:
```
B → i1 rop i2 { B.T := ip;
                emit(if i1 rop i2 goto 0);
                B.F := ip;
                emit(goto 0)
              }
```

##### 无条件转移语句的翻译

```
lable → i;
S → goto i;
```

1. 向前转移
   
   ```
   L:
   ...
   goto L;
   ```

   其翻译方法为 `S → goto L{emit(goto L)}`

2. 向后转移
   
   ```
   goto L;
   ...
   L:
   ```

   在向后转移的时候, 首先遇到 `goto L` 语句, 此时 L 未知, 只能将 L 填入符号表, 并标记未定义. 所以对 `goto L` 只能生成不确定的三地址语句 `goto 0`, 它的转移目标必须在 L 定义时再返填进去. 有可能有几个 goto 语句都转移到同一个未定义的 L, 所以必须记住所有的待返填的三地址语句, 用一个链表来保存.

   | 名字 | 类型 | ... | 是否定义 | 地址 |
   | ---- | ---- | --- | -------- | ---- |
   | ...  |      |     |          |      |
   | L    | 标号 |     | 否       | r    |
   |      |      |     |          |      |
   
   表中的 r 指向一个链表, 类似这样的格式 `r -> goto q -> goto p -> goto 0` 

   然后此处新引入了一个语义函数 `backpatch(r, ip)` , 用来把 r 为链首的链上的所有三地址语句的转移目标都填为 ip 的当前值.
   
##### 条件语句的翻译

简单起见, 考虑下面的产生式

```
S → if B then S1
S → if B then S1 else S2
```

对于 `S → if B then S1`

![](https://raw.githubusercontent.com/zgw0/blog/master/imgs/by1.png)

如上图所示, 整个语句翻译完成后 B.F 仍不能确定, 只能将它作为 S 的语义值 S.CHAIN 暂时保留下来. 如果 S<sub>1</sub> 本身也是控制语句, 它也有语义值 S<sub>1</sub>.CHAIN 未确定, 则 B.F 和 S<sub>1</sub>.CHAIN 应转到同一个地方, 因此要将他们链接起来, 链首地址记录在 S 的语义值 S.CHAIN 中, 这项工作由语义函数 `merge()` 完成.

`merge(P1, P2)` 把以 P<sub>1</sub> 和 P<sub>2</sub> 为首的两条链合并为一条链, 回送的函数值为合并后的链首 P<sub>2</sub>.