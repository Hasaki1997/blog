<!DOCTYPE html>
<!-- saved from url=(0053)http://blog.codingplayboy.com/2017/12/02/react_fiber/ -->
<html lang="zh-CN" class=" no-touch"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">

<meta name="viewport" content="width=device-width, initial-scale=1">
<link rel="profile" href="http://gmpg.org/xfn/11">
<link rel="pingback" href="http://blog.codingplayboy.com/xmlrpc.php">

<title>React Fiber初探 – 熊建刚的博客</title>
<link rel="dns-prefetch" href="http://fonts.googleapis.com/">
<link rel="dns-prefetch" href="http://s.w.org/">
<link rel="alternate" type="application/rss+xml" title="熊建刚的博客 » Feed" href="http://blog.codingplayboy.com/feed/">
<link rel="alternate" type="application/rss+xml" title="熊建刚的博客 » 评论Feed" href="http://blog.codingplayboy.com/comments/feed/">
<link rel="alternate" type="application/rss+xml" title="熊建刚的博客 » React Fiber初探评论Feed" href="http://blog.codingplayboy.com/2017/12/02/react_fiber/feed/">
		<script type="text/javascript">
			window._wpemojiSettings = {"baseUrl":"https:\/\/s.w.org\/images\/core\/emoji\/2.4\/72x72\/","ext":".png","svgUrl":"https:\/\/s.w.org\/images\/core\/emoji\/2.4\/svg\/","svgExt":".svg","source":{"concatemoji":"http:\/\/blog.codingplayboy.com\/wp-includes\/js\/wp-emoji-release.min.js?ver=4.9.3"}};
			!function(a,b,c){function d(a,b){var c=String.fromCharCode;l.clearRect(0,0,k.width,k.height),l.fillText(c.apply(this,a),0,0);var d=k.toDataURL();l.clearRect(0,0,k.width,k.height),l.fillText(c.apply(this,b),0,0);var e=k.toDataURL();return d===e}function e(a){var b;if(!l||!l.fillText)return!1;switch(l.textBaseline="top",l.font="600 32px Arial",a){case"flag":return!(b=d([55356,56826,55356,56819],[55356,56826,8203,55356,56819]))&&(b=d([55356,57332,56128,56423,56128,56418,56128,56421,56128,56430,56128,56423,56128,56447],[55356,57332,8203,56128,56423,8203,56128,56418,8203,56128,56421,8203,56128,56430,8203,56128,56423,8203,56128,56447]),!b);case"emoji":return b=d([55357,56692,8205,9792,65039],[55357,56692,8203,9792,65039]),!b}return!1}function f(a){var c=b.createElement("script");c.src=a,c.defer=c.type="text/javascript",b.getElementsByTagName("head")[0].appendChild(c)}var g,h,i,j,k=b.createElement("canvas"),l=k.getContext&&k.getContext("2d");for(j=Array("flag","emoji"),c.supports={everything:!0,everythingExceptFlag:!0},i=0;i<j.length;i++)c.supports[j[i]]=e(j[i]),c.supports.everything=c.supports.everything&&c.supports[j[i]],"flag"!==j[i]&&(c.supports.everythingExceptFlag=c.supports.everythingExceptFlag&&c.supports[j[i]]);c.supports.everythingExceptFlag=c.supports.everythingExceptFlag&&!c.supports.flag,c.DOMReady=!1,c.readyCallback=function(){c.DOMReady=!0},c.supports.everything||(h=function(){c.readyCallback()},b.addEventListener?(b.addEventListener("DOMContentLoaded",h,!1),a.addEventListener("load",h,!1)):(a.attachEvent("onload",h),b.attachEvent("onreadystatechange",function(){"complete"===b.readyState&&c.readyCallback()})),g=c.source||{},g.concatemoji?f(g.concatemoji):g.wpemoji&&g.twemoji&&(f(g.twemoji),f(g.wpemoji)))}(window,document,window._wpemojiSettings);
		</script><script src="./React Fiber初探 – 熊建刚的博客_files/wp-emoji-release.min.js" type="text/javascript" defer=""></script>
		<style type="text/css">
img.wp-smiley,
img.emoji {
	display: inline !important;
	border: none !important;
	box-shadow: none !important;
	height: 1em !important;
	width: 1em !important;
	margin: 0 .07em !important;
	vertical-align: -0.1em !important;
	background: none !important;
	padding: 0 !important;
}
</style>
<link rel="stylesheet" id="toc-screen-css" href="./React Fiber初探 – 熊建刚的博客_files/screen.min.css" type="text/css" media="all">
<link rel="stylesheet" id="xmag-fonts-css" href="./React Fiber初探 – 熊建刚的博客_files/css" type="text/css" media="all">
<link rel="stylesheet" id="xmag-icons-css" href="./React Fiber初探 – 熊建刚的博客_files/simple-line-icons.css" type="text/css" media="all">
<link rel="stylesheet" id="xmag-style-css" href="./React Fiber初探 – 熊建刚的博客_files/style.min.css" type="text/css" media="all">
<style id="xmag-style-inline-css" type="text/css">

		.main-navbar {
		background-color: #fff;
		border-top: 1px solid #eee;
		border-bottom: 1px solid #eee;
		-webkit-box-shadow: 0 3px 2px 0 rgba(0, 0, 0, 0.03);
		box-shadow: 0 3px 2px 0 rgba(0, 0, 0, 0.03);
		}
		.main-menu > li > a,
		.main-navigation .home-link a {
		color: #333;
		border-left: 1px solid #f2f2f2;
		}
		.main-menu > li:last-child > a {
		border-right: 1px solid #f2f2f2;
		}
		.main-menu > li > a:hover,
		.main-navigation .home-link a:hover {
		background-color: #fff;
		color: ;
		}
		.main-navigation .home-link a:hover:before,
		.main-menu > li:hover:before,
		.main-menu > li:active:before,
		.main-menu > li.current_page_item:before,
		.main-menu > li.current-menu-item:before {
		content: '';
		position: absolute;
		bottom: 0;
		left: 0;
		display: block;
		width: 100%;
		height: 2px;
		z-index: 2;
		background-color: ;	
		}
		.main-menu ul {
		background-color: #fff;
		border: 1px solid #eee;
		}
		.main-menu ul a {
		border-top: 1px solid #f2f2f2;
		color: #555;
		}
		.main-menu ul a:hover {
		color: ;
		}
		#mobile-header {
		background-color: #fff;
		border-bottom: 1px solid #eee;
		-webkit-box-shadow: 0 3px 2px 0 rgba(0, 0, 0, 0.03);
		box-shadow: 0 3px 2px 0 rgba(0, 0, 0, 0.03);
		}
		#mobile-header .mobile-title, 
		#mobile-header .mobile-menu-toggle {
		color: #333;
		}
		.button-toggle,
		.button-toggle:before,
		.button-toggle:after {
		background-color: #333;
		} 
</style>
<script type="text/javascript" src="./React Fiber初探 – 熊建刚的博客_files/jquery.js"></script>
<script type="text/javascript" src="./React Fiber初探 – 熊建刚的博客_files/jquery-migrate.min.js"></script>
<link rel="https://api.w.org/" href="http://blog.codingplayboy.com/wp-json/">
<link rel="EditURI" type="application/rsd+xml" title="RSD" href="http://blog.codingplayboy.com/xmlrpc.php?rsd">
<link rel="wlwmanifest" type="application/wlwmanifest+xml" href="http://blog.codingplayboy.com/wp-includes/wlwmanifest.xml"> 
<link rel="prev" title="Linux下php-fpm进程过多导致内存耗尽问题解决" href="http://blog.codingplayboy.com/2017/11/30/linux_php-fpm_memory_problem/">
<link rel="next" title="解决Nginx服务返回500状态码问题" href="http://blog.codingplayboy.com/2017/12/12/nginx-error-500/">
<meta name="generator" content="WordPress 4.9.3">
<link rel="canonical" href="http://blog.codingplayboy.com/2017/12/02/react_fiber/">
<link rel="shortlink" href="http://blog.codingplayboy.com/?p=888">
<link rel="alternate" type="application/json+oembed" href="http://blog.codingplayboy.com/wp-json/oembed/1.0/embed?url=http%3A%2F%2Fblog.codingplayboy.com%2F2017%2F12%2F02%2Freact_fiber%2F">
<link rel="alternate" type="text/xml+oembed" href="http://blog.codingplayboy.com/wp-json/oembed/1.0/embed?url=http%3A%2F%2Fblog.codingplayboy.com%2F2017%2F12%2F02%2Freact_fiber%2F&amp;format=xml">
		<style type="text/css">.recentcomments a{display:inline !important;padding:0 !important;margin:0 !important;}</style>
		<link rel="icon" href="http://blog.codingplayboy.com/wp-content/uploads/2016/06/cropped-profile-32x32.jpg" sizes="32x32">
<link rel="icon" href="http://blog.codingplayboy.com/wp-content/uploads/2016/06/cropped-profile-192x192.jpg" sizes="192x192">
<link rel="apple-touch-icon-precomposed" href="http://blog.codingplayboy.com/wp-content/uploads/2016/06/cropped-profile-180x180.jpg">
<meta name="msapplication-TileImage" content="http://blog.codingplayboy.com/wp-content/uploads/2016/06/cropped-profile-270x270.jpg">
<style type="text/css">/*
 * contextMenu.js v 1.4.0
 * Author: Sudhanshu Yadav
 * s-yadav.github.com
 * Copyright (c) 2013 Sudhanshu Yadav.
 * Dual licensed under the MIT and GPL licenses
**/

.iw-contextMenu {
    box-shadow: 0px 2px 3px rgba(0, 0, 0, 0.10);
    border: 1px solid #c8c7cc;
    border-radius: 11px;
    display: none;
    z-index: 1000000132;
    max-width: 300px;
}

.iw-cm-menu {
    background: #fff;
    color: #000;
    margin: 0px;
    padding: 0px;
}

.iw-curMenu {
}

.iw-cm-menu li {
    font-family: -apple-system, BlinkMacSystemFont, "Helvetica Neue", Helvetica, Arial, Ubuntu, sans-serif;
    list-style: none;
    padding: 10px;
    padding-right: 20px;
    border-bottom: 1px solid #c8c7cc;
    cursor: pointer;
    position: relative;
    font-size: 14px;
    margin: 0;
    line-height: inherit;
}

.iw-cm-menu li:first-child {
    border-top-left-radius: 11px;
    border-top-right-radius: 11px;
}

.iw-cm-menu li:last-child {
    border-bottom-left-radius: 11px;
    border-bottom-right-radius: 11px;
    border-bottom: none;
}

.iw-mOverlay {
    position: absolute;
    width: 100%;
    height: 100%;
    top: 0px;
    left: 0px;
    background: #FFF;
    opacity: .5;
}

.iw-contextMenu li.iw-mDisable {
    opacity: 0.3;
    cursor: default;
}

.iw-mSelected {
    background-color: #F6F6F6;
}

.iw-cm-arrow-right {
    width: 0;
    height: 0;
    border-top: 5px solid transparent;
    border-bottom: 5px solid transparent;
    border-left: 5px solid #000;
    position: absolute;
    right: 5px;
    top: 50%;
    margin-top: -5px;
}

.iw-mSelected > .iw-cm-arrow-right {
}

/*context menu css end */</style><style type="text/css">@-webkit-keyframes load4 {
    0%,
    100% {
        box-shadow: 0 -3em 0 0.2em, 2em -2em 0 0em, 3em 0 0 -1em, 2em 2em 0 -1em, 0 3em 0 -1em, -2em 2em 0 -1em, -3em 0 0 -1em, -2em -2em 0 0;
    }
    12.5% {
        box-shadow: 0 -3em 0 0, 2em -2em 0 0.2em, 3em 0 0 0, 2em 2em 0 -1em, 0 3em 0 -1em, -2em 2em 0 -1em, -3em 0 0 -1em, -2em -2em 0 -1em;
    }
    25% {
        box-shadow: 0 -3em 0 -0.5em, 2em -2em 0 0, 3em 0 0 0.2em, 2em 2em 0 0, 0 3em 0 -1em, -2em 2em 0 -1em, -3em 0 0 -1em, -2em -2em 0 -1em;
    }
    37.5% {
        box-shadow: 0 -3em 0 -1em, 2em -2em 0 -1em, 3em 0em 0 0, 2em 2em 0 0.2em, 0 3em 0 0em, -2em 2em 0 -1em, -3em 0em 0 -1em, -2em -2em 0 -1em;
    }
    50% {
        box-shadow: 0 -3em 0 -1em, 2em -2em 0 -1em, 3em 0 0 -1em, 2em 2em 0 0em, 0 3em 0 0.2em, -2em 2em 0 0, -3em 0em 0 -1em, -2em -2em 0 -1em;
    }
    62.5% {
        box-shadow: 0 -3em 0 -1em, 2em -2em 0 -1em, 3em 0 0 -1em, 2em 2em 0 -1em, 0 3em 0 0, -2em 2em 0 0.2em, -3em 0 0 0, -2em -2em 0 -1em;
    }
    75% {
        box-shadow: 0em -3em 0 -1em, 2em -2em 0 -1em, 3em 0em 0 -1em, 2em 2em 0 -1em, 0 3em 0 -1em, -2em 2em 0 0, -3em 0em 0 0.2em, -2em -2em 0 0;
    }
    87.5% {
        box-shadow: 0em -3em 0 0, 2em -2em 0 -1em, 3em 0 0 -1em, 2em 2em 0 -1em, 0 3em 0 -1em, -2em 2em 0 0, -3em 0em 0 0, -2em -2em 0 0.2em;
    }
}

@keyframes load4 {
    0%,
    100% {
        box-shadow: 0 -3em 0 0.2em, 2em -2em 0 0em, 3em 0 0 -1em, 2em 2em 0 -1em, 0 3em 0 -1em, -2em 2em 0 -1em, -3em 0 0 -1em, -2em -2em 0 0;
    }
    12.5% {
        box-shadow: 0 -3em 0 0, 2em -2em 0 0.2em, 3em 0 0 0, 2em 2em 0 -1em, 0 3em 0 -1em, -2em 2em 0 -1em, -3em 0 0 -1em, -2em -2em 0 -1em;
    }
    25% {
        box-shadow: 0 -3em 0 -0.5em, 2em -2em 0 0, 3em 0 0 0.2em, 2em 2em 0 0, 0 3em 0 -1em, -2em 2em 0 -1em, -3em 0 0 -1em, -2em -2em 0 -1em;
    }
    37.5% {
        box-shadow: 0 -3em 0 -1em, 2em -2em 0 -1em, 3em 0em 0 0, 2em 2em 0 0.2em, 0 3em 0 0em, -2em 2em 0 -1em, -3em 0em 0 -1em, -2em -2em 0 -1em;
    }
    50% {
        box-shadow: 0 -3em 0 -1em, 2em -2em 0 -1em, 3em 0 0 -1em, 2em 2em 0 0em, 0 3em 0 0.2em, -2em 2em 0 0, -3em 0em 0 -1em, -2em -2em 0 -1em;
    }
    62.5% {
        box-shadow: 0 -3em 0 -1em, 2em -2em 0 -1em, 3em 0 0 -1em, 2em 2em 0 -1em, 0 3em 0 0, -2em 2em 0 0.2em, -3em 0 0 0, -2em -2em 0 -1em;
    }
    75% {
        box-shadow: 0em -3em 0 -1em, 2em -2em 0 -1em, 3em 0em 0 -1em, 2em 2em 0 -1em, 0 3em 0 -1em, -2em 2em 0 0, -3em 0em 0 0.2em, -2em -2em 0 0;
    }
    87.5% {
        box-shadow: 0em -3em 0 0, 2em -2em 0 -1em, 3em 0 0 -1em, 2em 2em 0 -1em, 0 3em 0 -1em, -2em 2em 0 0, -3em 0em 0 0, -2em -2em 0 0.2em;
    }
}</style><style type="text/css">/* This is not a zero-length file! */</style></head>
<body class="post-template-default single single-post postid-888 single-format-standard site-fullwidth">
	
<div id="page" class="hfeed site">
	
	<a class="skip-link screen-reader-text" href="http://blog.codingplayboy.com/2017/12/02/react_fiber/#content">Skip to content</a>
	
	<aside id="mobile-header" class="mobile-header">
		<a class="mobile-menu-toggle" id="mobile-menu-toggle" href="http://blog.codingplayboy.com/2017/12/02/react_fiber/#mobile-nav" title="Menu"><span class="button-toggle"></span></a>
		<a class="mobile-title" href="http://blog.codingplayboy.com/" rel="home">熊建刚的博客</a>
	</aside>
	
	<nav id="mobile-navigation" class="mobile-navigation" role="navigation"><div class="home-link mobile-menu">
		                     <a href="http://blog.codingplayboy.com/" title="熊建刚的博客" rel="home"><span class="icon-home"></span></a>
		                </div><ul class="mobile-menu"><li id="menu-item-615" class="menu-item menu-item-type-taxonomy menu-item-object-category menu-item-has-children menu-item-615"><a href="http://blog.codingplayboy.com/category/html/">HTML</a>
<ul class="sub-menu">
	<li id="menu-item-605" class="menu-item menu-item-type-taxonomy menu-item-object-category menu-item-605"><a href="http://blog.codingplayboy.com/category/html/html5/">HTML5</a></li>
</ul>
</li>
<li id="menu-item-603" class="menu-item menu-item-type-taxonomy menu-item-object-category menu-item-has-children menu-item-603"><a href="http://blog.codingplayboy.com/category/css/">CSS</a>
<ul class="sub-menu">
	<li id="menu-item-607" class="menu-item menu-item-type-taxonomy menu-item-object-category menu-item-607"><a href="http://blog.codingplayboy.com/category/css/css3/">CSS3</a></li>
</ul>
</li>
<li id="menu-item-602" class="menu-item menu-item-type-taxonomy menu-item-object-category menu-item-602"><a href="http://blog.codingplayboy.com/category/js/">JavaScript</a></li>
<li id="menu-item-604" class="menu-item menu-item-type-taxonomy menu-item-object-category menu-item-604"><a href="http://blog.codingplayboy.com/category/gitsvn/">Git/SVN</a></li>
<li id="menu-item-613" class="menu-item menu-item-type-taxonomy menu-item-object-category menu-item-has-children menu-item-613"><a href="http://blog.codingplayboy.com/category/mobile/">移动开发</a>
<ul class="sub-menu">
	<li id="menu-item-872" class="menu-item menu-item-type-taxonomy menu-item-object-category menu-item-872"><a href="http://blog.codingplayboy.com/category/mobile/react-native/">React Native</a></li>
</ul>
</li>
<li id="menu-item-616" class="menu-item menu-item-type-taxonomy menu-item-object-category current-post-ancestor menu-item-has-children menu-item-616"><a href="http://blog.codingplayboy.com/category/spa/">单页应用</a>
<ul class="sub-menu">
	<li id="menu-item-609" class="menu-item menu-item-type-taxonomy menu-item-object-category current-post-ancestor current-menu-parent current-post-parent menu-item-609"><a href="http://blog.codingplayboy.com/category/spa/reactjs/">React</a></li>
	<li id="menu-item-786" class="menu-item menu-item-type-taxonomy menu-item-object-category menu-item-786"><a href="http://blog.codingplayboy.com/category/spa/vue/">Vue</a></li>
	<li id="menu-item-611" class="menu-item menu-item-type-taxonomy menu-item-object-category menu-item-611"><a href="http://blog.codingplayboy.com/category/spa/backbone/">Backbone</a></li>
</ul>
</li>
</ul><ul class="mobile-menu"><li id="menu-item-694" class="menu-item menu-item-type-custom menu-item-object-custom menu-item-694"><a href="http://demo.codingplayboy.com/">实例</a></li>
<li id="menu-item-651" class="menu-item menu-item-type-post_type menu-item-object-page menu-item-651"><a href="http://blog.codingplayboy.com/read/">读书</a></li>
<li id="menu-item-650" class="menu-item menu-item-type-post_type menu-item-object-page menu-item-650"><a href="http://blog.codingplayboy.com/resource/">资源</a></li>
<li id="menu-item-652" class="menu-item menu-item-type-post_type menu-item-object-page menu-item-652"><a href="http://blog.codingplayboy.com/aboutme/">关于</a></li>
</ul></nav>

	<header id="masthead" class="site-header" role="banner">
		
		<div class="header-top collapse">
			<div class="container">
				<div class="row">
					<div class="col-4">
						<div class="site-branding">
																<p class="site-title"><a href="http://blog.codingplayboy.com/" rel="home">熊建刚的博客</a></p>
														
																							<p class="site-description">热爱前端，但不局限于前端</p>
													</div><!-- .site-branding -->
					</div>
					<div class="col-8">
						<div class="header-navigation">
															<div class="search-top">
									
<form role="search" method="get" class="search-form" action="http://blog.codingplayboy.com/">
	<label>
		<span class="screen-reader-text">Search for:</span>
		<input type="search" class="search-field" placeholder="Search …" value="" name="s">
	</label>
	<button type="submit" class="search-submit"><span class="sli icon-magnifier"></span> <span class="screen-reader-text">Search</span></button>
</form>
								</div>
							<!-- Search Form -->
							<nav id="top-navigation" class="top-navigation" role="navigation">
								<ul id="menu-%e9%a1%b5%e9%9d%a2" class="top-menu"><li id="menu-item-694" class="menu-item menu-item-type-custom menu-item-object-custom menu-item-694"><a href="http://demo.codingplayboy.com/">实例</a></li>
<li id="menu-item-651" class="menu-item menu-item-type-post_type menu-item-object-page menu-item-651"><a href="http://blog.codingplayboy.com/read/">读书</a></li>
<li id="menu-item-650" class="menu-item menu-item-type-post_type menu-item-object-page menu-item-650"><a href="http://blog.codingplayboy.com/resource/">资源</a></li>
<li id="menu-item-652" class="menu-item menu-item-type-post_type menu-item-object-page menu-item-652"><a href="http://blog.codingplayboy.com/aboutme/">关于</a></li>
</ul>							</nav><!-- #top-navigation -->
						</div>
					</div>
				</div><!-- .row -->
			</div>
		</div><!-- Header Top -->
		
					
		<nav id="main-navbar" class="main-navbar">
			<div class="container">
				<div id="main-navigation" class="main-navigation">
											<div class="home-link">
		                     <a href="http://blog.codingplayboy.com/" title="熊建刚的博客" rel="home"><span class="icon-home"></span></a>
		                </div>
										
					<ul id="menu-%e5%af%bc%e8%88%aa" class="main-menu"><li id="menu-item-615" class="menu-item menu-item-type-taxonomy menu-item-object-category menu-item-has-children menu-item-615"><a href="http://blog.codingplayboy.com/category/html/">HTML</a>
<ul class="sub-menu">
	<li id="menu-item-605" class="menu-item menu-item-type-taxonomy menu-item-object-category menu-item-605"><a href="http://blog.codingplayboy.com/category/html/html5/">HTML5</a></li>
</ul>
</li>
<li id="menu-item-603" class="menu-item menu-item-type-taxonomy menu-item-object-category menu-item-has-children menu-item-603"><a href="http://blog.codingplayboy.com/category/css/">CSS</a>
<ul class="sub-menu">
	<li id="menu-item-607" class="menu-item menu-item-type-taxonomy menu-item-object-category menu-item-607"><a href="http://blog.codingplayboy.com/category/css/css3/">CSS3</a></li>
</ul>
</li>
<li id="menu-item-602" class="menu-item menu-item-type-taxonomy menu-item-object-category menu-item-602"><a href="http://blog.codingplayboy.com/category/js/">JavaScript</a></li>
<li id="menu-item-604" class="menu-item menu-item-type-taxonomy menu-item-object-category menu-item-604"><a href="http://blog.codingplayboy.com/category/gitsvn/">Git/SVN</a></li>
<li id="menu-item-613" class="menu-item menu-item-type-taxonomy menu-item-object-category menu-item-has-children menu-item-613"><a href="http://blog.codingplayboy.com/category/mobile/">移动开发</a>
<ul class="sub-menu">
	<li id="menu-item-872" class="menu-item menu-item-type-taxonomy menu-item-object-category menu-item-872"><a href="http://blog.codingplayboy.com/category/mobile/react-native/">React Native</a></li>
</ul>
</li>
<li id="menu-item-616" class="menu-item menu-item-type-taxonomy menu-item-object-category current-post-ancestor menu-item-has-children menu-item-616"><a href="http://blog.codingplayboy.com/category/spa/">单页应用</a>
<ul class="sub-menu">
	<li id="menu-item-609" class="menu-item menu-item-type-taxonomy menu-item-object-category current-post-ancestor current-menu-parent current-post-parent menu-item-609"><a href="http://blog.codingplayboy.com/category/spa/reactjs/">React</a></li>
	<li id="menu-item-786" class="menu-item menu-item-type-taxonomy menu-item-object-category menu-item-786"><a href="http://blog.codingplayboy.com/category/spa/vue/">Vue</a></li>
	<li id="menu-item-611" class="menu-item menu-item-type-taxonomy menu-item-object-category menu-item-611"><a href="http://blog.codingplayboy.com/category/spa/backbone/">Backbone</a></li>
</ul>
</li>
</ul>				</div>
			</div>
		</nav><!-- Main Navbar -->
	
	</header><!-- #masthead -->
	
	<div id="content" class="site-content">
		<div class="container">
			
		
		
	<div id="primary" class="content-area">
		<main id="main" class="site-main" role="main">
		
					
				
<article id="post-888" class="post-888 post type-post status-publish format-standard hentry category-reactjs tag-fiber tag-react tag-reconciliation">

		
		<header class="entry-header">
			<h1 class="entry-title">React Fiber初探</h1>			<div class="entry-meta">
				<span class="posted-on"><span class="icon-clock"></span> <a href="http://blog.codingplayboy.com/2017/12/02/react_fiber/" rel="bookmark"><time class="entry-date published" datetime="2017-12-02T17:47:34+00:00">2017-12-02</time><time class="updated" datetime="2017-12-02T17:52:43+00:00">2017-12-02</time></a></span><span class="byline"> by <span class="author vcard"><a class="url fn n" href="http://blog.codingplayboy.com/author/jhss_xjg/">熊 建刚</a></span></span>				<span class="sep">/</span>
				<span class="comments-link"><a href="http://blog.codingplayboy.com/2017/12/02/react_fiber/#comments"><span class="icon-bubbles"></span> 1</a></span><span class="sep">/</span><span class="page-views"><span class="icon-user"></span><span class="view-num"> 3704</span></span>			</div>
		</header><!-- .entry-header -->
		
			
	<div class="entry-content">
		<p>React 16版本已经推出多时，提出了包括Portal，异常边界等新特性，最重要的是重写了调和算法，推出了新版本算法实现-Fiber，于是博主历时三周，在业余时间学习Fiber架构实现和源码，对Fiber整体有了初步了解，并总结分享出来，若对一些源码不感兴趣，大可跳过，另博主水平有限，若有不对之处，欢迎指正。</p>
<div id="toc_container" class="toc_light_blue no_bullets"><p class="toc_title">索引 <span class="toc_toggle">[<a href="http://blog.codingplayboy.com/2017/12/02/react_fiber/#">隐藏</a>]</span></p><ul class="toc_list"><li><a href="http://blog.codingplayboy.com/2017/12/02/react_fiber/#i"><span class="toc_number toc_depth_1">1</span> 前言</a></li><li><a href="http://blog.codingplayboy.com/2017/12/02/react_fiber/#i-2"><span class="toc_number toc_depth_1">2</span> 渲染</a></li><li><a href="http://blog.codingplayboy.com/2017/12/02/react_fiber/#Reconciliation"><span class="toc_number toc_depth_1">3</span> 调和（Reconciliation）</a><ul><li><a href="http://blog.codingplayboy.com/2017/12/02/react_fiber/#Stack_Reconciler"><span class="toc_number toc_depth_2">3.1</span> Stack Reconciler</a></li><li><a href="http://blog.codingplayboy.com/2017/12/02/react_fiber/#Fiber_Reconciler"><span class="toc_number toc_depth_2">3.2</span> Fiber Reconciler</a></li></ul></li><li><a href="http://blog.codingplayboy.com/2017/12/02/react_fiber/#FiberJavaScript"><span class="toc_number toc_depth_1">4</span> Fiber与JavaScript</a><ul><li><a href="http://blog.codingplayboy.com/2017/12/02/react_fiber/#Idle_Period"><span class="toc_number toc_depth_2">4.1</span> 空闲期（Idle Period）</a></li><li><a href="http://blog.codingplayboy.com/2017/12/02/react_fiber/#FiberrequestIdleCallback"><span class="toc_number toc_depth_2">4.2</span> Fiber与requestIdleCallback</a></li></ul></li><li><a href="http://blog.codingplayboy.com/2017/12/02/react_fiber/#Fiber"><span class="toc_number toc_depth_1">5</span> Fiber与组件</a></li><li><a href="http://blog.codingplayboy.com/2017/12/02/react_fiber/#Fiber-2"><span class="toc_number toc_depth_1">6</span> Fiber数据结构</a><ul><li><a href="http://blog.codingplayboy.com/2017/12/02/react_fiber/#Fiber-3"><span class="toc_number toc_depth_2">6.1</span> Fiber对象</a><ul><li><a href="http://blog.codingplayboy.com/2017/12/02/react_fiber/#alternate_fiber"><span class="toc_number toc_depth_3">6.1.1</span> alternate fiber</a></li><li><a href="http://blog.codingplayboy.com/2017/12/02/react_fiber/#Fiber-4"><span class="toc_number toc_depth_3">6.1.2</span> 创建Fiber实例</a></li></ul></li><li><a href="http://blog.codingplayboy.com/2017/12/02/react_fiber/#Fiber-5"><span class="toc_number toc_depth_2">6.2</span> Fiber类型</a></li><li><a href="http://blog.codingplayboy.com/2017/12/02/react_fiber/#FiberRoot"><span class="toc_number toc_depth_2">6.3</span> FiberRoot对象</a><ul><li><a href="http://blog.codingplayboy.com/2017/12/02/react_fiber/#FiberRoot-2"><span class="toc_number toc_depth_3">6.3.1</span> 创建FiberRoot实例</a></li></ul></li><li><a href="http://blog.codingplayboy.com/2017/12/02/react_fiber/#ReactChildFiber"><span class="toc_number toc_depth_2">6.4</span> ReactChildFiber</a></li></ul></li><li><a href="http://blog.codingplayboy.com/2017/12/02/react_fiber/#Fiber-6"><span class="toc_number toc_depth_1">7</span> Fiber架构</a><ul><li><a href="http://blog.codingplayboy.com/2017/12/02/react_fiber/#ExpirationTime_VS_PriorityLevel"><span class="toc_number toc_depth_2">7.1</span> 优先级（ExpirationTime VS PriorityLevel）</a><ul><li><a href="http://blog.codingplayboy.com/2017/12/02/react_fiber/#ExpirationTime"><span class="toc_number toc_depth_3">7.1.1</span> ExpirationTime</a></li><li><a href="http://blog.codingplayboy.com/2017/12/02/react_fiber/#PriorityLevel"><span class="toc_number toc_depth_3">7.1.2</span> PriorityLevel</a></li></ul></li><li><a href="http://blog.codingplayboy.com/2017/12/02/react_fiber/#Scheduler"><span class="toc_number toc_depth_2">7.2</span> 调度器（Scheduler）</a><ul><li><a href="http://blog.codingplayboy.com/2017/12/02/react_fiber/#i-3"><span class="toc_number toc_depth_3">7.2.1</span> 调度器与优先级</a></li><li><a href="http://blog.codingplayboy.com/2017/12/02/react_fiber/#i-4"><span class="toc_number toc_depth_3">7.2.2</span> 任务调度</a></li></ul></li><li><a href="http://blog.codingplayboy.com/2017/12/02/react_fiber/#UpdateQueue"><span class="toc_number toc_depth_2">7.3</span> 更新队列（UpdateQueue）</a></li><li><a href="http://blog.codingplayboy.com/2017/12/02/react_fiber/#Updater"><span class="toc_number toc_depth_2">7.4</span> 更新器（Updater）</a><ul><li><a href="http://blog.codingplayboy.com/2017/12/02/react_fiber/#fiber"><span class="toc_number toc_depth_3">7.4.1</span> 获取fiber实例</a></li><li><a href="http://blog.codingplayboy.com/2017/12/02/react_fiber/#i-5"><span class="toc_number toc_depth_3">7.4.2</span> 获取优先级</a></li><li><a href="http://blog.codingplayboy.com/2017/12/02/react_fiber/#i-6"><span class="toc_number toc_depth_3">7.4.3</span> 将更新任务添加至更新队列</a></li><li><a href="http://blog.codingplayboy.com/2017/12/02/react_fiber/#i-7"><span class="toc_number toc_depth_3">7.4.4</span> 调度更新任务</a></li></ul></li></ul></li><li><a href="http://blog.codingplayboy.com/2017/12/02/react_fiber/#i-8"><span class="toc_number toc_depth_1">8</span> 渲染与调和</a><ul><li><a href="http://blog.codingplayboy.com/2017/12/02/react_fiber/#i-9"><span class="toc_number toc_depth_2">8.1</span> 源码简单分析</a><ul><li><a href="http://blog.codingplayboy.com/2017/12/02/react_fiber/#react-dom"><span class="toc_number toc_depth_3">8.1.1</span> react-dom渲染模块</a><ul><li><a href="http://blog.codingplayboy.com/2017/12/02/react_fiber/#DOM"><span class="toc_number toc_depth_4">8.1.1.1</span> DOM渲染器对象</a></li></ul></li><li><a href="http://blog.codingplayboy.com/2017/12/02/react_fiber/#i-10"><span class="toc_number toc_depth_3">8.1.2</span> 调和算法入口</a><ul><li><a href="http://blog.codingplayboy.com/2017/12/02/react_fiber/#i-11"><span class="toc_number toc_depth_4">8.1.2.1</span> 开始更新</a></li><li><a href="http://blog.codingplayboy.com/2017/12/02/react_fiber/#i-12"><span class="toc_number toc_depth_4">8.1.2.2</span> 处理更新</a></li><li><a href="http://blog.codingplayboy.com/2017/12/02/react_fiber/#i-13"><span class="toc_number toc_depth_4">8.1.2.3</span> 提交更新</a></li></ul></li></ul></li></ul></li><li><a href="http://blog.codingplayboy.com/2017/12/02/react_fiber/#i-14"><span class="toc_number toc_depth_1">9</span> 参考</a></li></ul></div>
<h2><span id="i">前言</span></h2>
<p>React的定位是一个构建用户界面的JavaScript类库，它使用JavaScript语言开发UI组件，可以使用多种方式渲染这些组件，输出用户界面，较大程度的达到了跨技术栈跨平台的兼容重用：</p>
<blockquote>
<p>We don’t make assumptions about the rest of your technology stack, so you can develop new features in React without rewriting existing code.</p>
</blockquote>
<p>现在的React已然在以下几个方面发挥的都很不错：</p>
<ol>
<li>React Web应用用户界面开发；</li>
<li>React Native App用户界面开发；</li>
<li>Node.js服务端渲染；</li>
</ol>
<p>在这些不同场景，渲染的主体很明显是不一样的，有诸如web应用的DOM渲染，React Native的原生View渲染，服务端字符串渲染等，要做到兼容适应多种不同渲染环境，很显然，React不能局限固定渲染UI的方式。</p>
<p>React核心内容也确实只包括定义组件相关的内容和API，<a href="https://github.com/facebook/react/tree/master/packages/react">源码可以查看</a>，实际项目中，可以看到首先需要使用如下代码：</p>
<pre><code class="react hljs coffeescript"><span class="hljs-keyword">import</span> React <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>;
</code></pre>
<p>这句代码做的就是引入了React核心源码模块。</p>
<h2><span id="i-2">渲染</span></h2>
<p>上一节已经说到React核心内容只涉及如何定义组件，并不涉及具体的组件渲染（即输出用户界面），这需要额外引入渲染模块，以渲染React定义的组件：</p>
<ol>
<li>
<p>React DOM渲染模块：将React组件渲染为DOM，然后可以被浏览器处理呈现给用户，这就是通常在web应用中引入的<code>react-dom</code>模块：</p>
<pre><code class="react hljs coffeescript"><span class="hljs-keyword">import</span> React <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>;
<span class="hljs-keyword">import</span> { render } <span class="hljs-keyword">from</span> <span class="hljs-string">'react-dom'</span>;
<span class="hljs-keyword">import</span> App <span class="hljs-keyword">from</span> <span class="hljs-string">'./apps/App.js'</span>;

render(
 &lt;App /&gt;,
 <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">'mainBox'</span>)
);
</code></pre>
<p>如上代码，<code>App</code>是使用React核心模块定义的组件，然后使用<code>react-dom</code>渲染模块提供的<code>render</code>方法将其渲染为DOM输出至页面。</p>
</li>
<li>
<p>React Native 渲染：将React组件渲染为移动端原生View，在React Native应用中引入<code>react-native</code>模块，它提供相应渲染方法可以渲染React组件：</p>
<pre><code class="react hljs coffeescript"><span class="hljs-keyword">import</span> { AppRegistry } <span class="hljs-keyword">from</span> <span class="hljs-string">'react-native'</span>;
<span class="hljs-keyword">import</span> App <span class="hljs-keyword">from</span> <span class="hljs-string">'./src/app.js'</span>;

AppRegistry.registerComponent(<span class="hljs-string">'fuc'</span>, <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> App);
</code></pre>
<p>如上，<code>App</code>是React根组件，使用<code>react-native</code>渲染器的<code>AppRegistry.registerComponent</code>方法将其渲染为原生View。</p>
</li>
<li>
<p>React测试渲染：将React组件渲染为JSON树，用来完成<a href="https://facebook.github.io/jest">Jest</a>的<a href="https://facebook.github.io/jest/blog/2016/07/27/jest-14.html">快照测试</a>，内容在<code>react-test-renderer</code>模块：</p>
<pre><code class="react hljs javascript"><span class="hljs-keyword">import</span> ReactTestRenderer <span class="hljs-keyword">from</span> <span class="hljs-string">'react-test-renderer'</span>;

<span class="hljs-keyword">const</span> renderer = ReactTestRenderer.create(
 <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">Link</span> <span class="hljs-attr">page</span>=<span class="hljs-string">"https://www.facebook.com/"</span>&gt;</span>Facebook<span class="hljs-tag">&lt;/<span class="hljs-name">Link</span>&gt;</span></span>
);

<span class="hljs-built_in">console</span>.log(renderer.toJSON());
<span class="hljs-comment">// { type: 'a',</span>
<span class="hljs-comment">//   props: { href: 'https://www.facebook.com/' },</span>
<span class="hljs-comment">//   children: [ 'Facebook' ] }</span>
</code></pre>
</li>
<li>
<p>React矢量图渲染：将React组件渲染为对应的适量图（<a href="https://github.com/sebmarkbage/art/">ART</a>库）；</p>
</li>
</ol>
<p><strong>web React应用是最常见的，也是最易于理解的，所以本篇后文均从React-DOM渲染器角度解析Fiber。</strong></p>
<h2><span id="Reconciliation">调和（Reconciliation）</span></h2>
<p>如前面两节所述，React核心是定义组件，渲染组件方式由环境决定，定义组件，组件状态管理，生命周期方法管理，组件更新等应该跨平台一致处理，不受渲染环境影响，这部分内容统一由<a href="https://github.com/facebook/react/tree/master/packages/react-reconciler">调和器（Reconciler）</a>处理，<a href="https://github.com/facebook/react/tree/master/packages/react-reconciler">源码传送</a>，不同渲染器都会使用该模块。调和器主要作用就是在组件状态变更时，调用组件树各组件的<code>render</code>方法，渲染，卸载组件。</p>
<h3><span id="Stack_Reconciler">Stack Reconciler</span></h3>
<p>我们知道浏览器渲染引擎是单线程的，在React 15.x版本及之前版本，计算组件树变更时将会阻塞整个线程，整个渲染过程是连续不中断完成的，而这时的其他任务都会被阻塞，如动画等，这可能会使用户感觉到明显卡顿，比如当你在访问某一网站时，输入某个搜索关键字，更优先的应该是交互反馈或动画效果，如果交互反馈延迟200ms，用户则会感觉较明显的卡顿，而数据响应晚200毫秒并没太大问题。这个版本的调和器可以称为栈调和器（Stack Reconciler），其调和算法大致过程见<a href="http://blog.codingplayboy.com/2016/10/27/react_diff/">React Diff算法</a> 和<a href="https://reactjs.org/docs/implementation-notes.html">React Stack Reconciler实现</a>。</p>
<p>Stack Reconcilier的主要缺陷就是不能暂停渲染任务，也不能切分任务，无法有效平衡组件更新渲染与动画相关任务间的执行顺序，即不能划分任务优先级，有可能导致重要任务卡顿，动画掉帧等问题。</p>
<h3><span id="Fiber_Reconciler">Fiber Reconciler</span></h3>
<p>React 16版本提出了一个更先进的调和器，它允许渲染进程分段完成，而不必须一次性完成，中间可以返回至主进程控制执行其他任务。而这是通过计算部分组件树的变更，并暂停渲染更新，询问主进程是否有更高需求的绘制或者更新任务需要执行，这些高需求的任务完成后才开始渲染。这一切的实现是在代码层引入了一个新的数据结构-Fiber对象，每一个组件实例对应有一个fiber实例，此fiber实例负责管理组件实例的更新，渲染任务及与其他fiber实例的联系。</p>
<p>这个新推出的调和器就叫做纤维调和器（Fiber Reconciler），它提供的新功能主要有：</p>
<ol>
<li>可切分，可中断任务；</li>
<li>可重用各分阶段任务，且可以设置优先级；</li>
<li>可以在父子组件任务间前进后退切换任务；</li>
<li><code>render</code>方法可以返回多元素（即可以返回数组）；</li>
<li>支持异常边界处理异常；</li>
</ol>
<p>说了这么多，终于要正式出场本篇主角：Fiber了，React最新版本已经升到16.1.1，估计16.x稳定版不会太远，让我们先睹为快吧。</p>
<h2><span id="FiberJavaScript">Fiber与JavaScript</span></h2>
<p>前面说到Fiber可以异步实现不同优先级任务的协调执行，那么对于DOM渲染器而言，在JavaScript层是否提供这种方式呢，还是说只能使用setTimeout模拟呢？目前新版本主流浏览器已经提供了可用API：<code>requestIdleCallback</code>和<code>requestAnimationFrame</code>:</p>
<ol>
<li><a href="https://www.w3.org/TR/requestidlecallback/">requestIdleCallback</a>: 在线程空闲时期调度执行低优先级函数；</li>
<li><a href="https://www.w3.org/TR/animation-timing/">requestAnimationFrame</a>: 在下一个动画帧调度执行高优先级函数；</li>
</ol>
<h3><span id="Idle_Period">空闲期（Idle Period）</span></h3>
<p>通常，客户端线程执行任务时会以帧的形式划分，大部分设备控制在30-60帧是不会影响用户体验；在两个执行帧之间，主线程通常会有一小段空闲时间，<code>requestIdleCallback</code>可以在这个<strong>空闲期（Idle Period）</strong>调用<strong>空闲期回调（Idle Callback）</strong>，执行一些任务。</p>
<p><img src="./React Fiber初探 – 熊建刚的博客_files/request-idle-callback.png" alt="requestIdleCallback"></p>
<h3><span id="FiberrequestIdleCallback">Fiber与requestIdleCallback</span></h3>
<p>Fiber所做的就是需要分解渲染任务，然后根据优先级使用API调度，异步执行指定任务：</p>
<ol>
<li>低优先级任务由<code>requestIdleCallback</code>处理；</li>
<li>高优先级任务，如动画相关的由<code>requestAnimationFrame</code>处理；</li>
<li><code>requestIdleCallback</code>可以在多个空闲期调用空闲期回调，执行任务；</li>
<li><code>requestIdleCallback</code>方法提供deadline，即任务执行限制时间，以切分任务，避免长时间执行，阻塞UI渲染而导致掉帧；</li>
</ol>
<p>具体<a href="https://github.com/facebook/react/blob/master/packages/shared/ReactDOMFrameScheduling.js">执行任务实现源码传送</a>：</p>
<ol>
<li>
<p>若支持原生API，具体原生实现见上文给出的链接：</p>
<pre><code class="react hljs coffeescript">rIC = <span class="hljs-built_in">window</span>.requestIdleCallback;
cIC = <span class="hljs-built_in">window</span>.cancelIdleCallback;
<span class="hljs-keyword">export</span> {now, rIC, cIC};
</code></pre>
</li>
<li>
<p>若不支持，则自定义实现：</p>
<pre><code class="react hljs javascript"><span class="hljs-keyword">let</span> isIdleScheduled = <span class="hljs-literal">false</span>; <span class="hljs-comment">// 是否在执行空闲期回调</span>
<span class="hljs-keyword">let</span> frameDeadlineObject = {
 <span class="hljs-attr">didTimeout</span>: <span class="hljs-literal">false</span>,
 timeRemaining() {
   <span class="hljs-comment">// now = Performance.now || Date.now</span>
   <span class="hljs-keyword">const</span> remaining = frameDeadline - now();
   <span class="hljs-comment">// 计算得到当前帧运行剩余时间</span>
   <span class="hljs-keyword">return</span> remaining &gt; <span class="hljs-number">0</span> ? remaining : <span class="hljs-number">0</span>;
 },
};
<span class="hljs-comment">// 帧回调</span>
<span class="hljs-keyword">const</span> animationTick = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">rafTime</span>) </span>{
 ...
 if (!isIdleScheduled) {
   <span class="hljs-comment">// 不在执行空闲期回调，表明可以调用空闲期回调</span>
   isIdleScheduled = <span class="hljs-literal">true</span>;
   <span class="hljs-comment">// 执行Idle空闲期回调</span>
   idleTick();
 }
};
<span class="hljs-comment">// 空闲期回调</span>
<span class="hljs-keyword">const</span> idleTick = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
 <span class="hljs-comment">// 重置为false，表明可以调用空闲期回调</span>
 isIdleScheduled = <span class="hljs-literal">false</span>;
 <span class="hljs-keyword">const</span> currentTime = now();
 <span class="hljs-keyword">if</span> (frameDeadline - currentTime &lt;= <span class="hljs-number">0</span>) {
   <span class="hljs-comment">// 帧到期时间小于当前时间，说明已过期</span>
   <span class="hljs-keyword">if</span> (timeoutTime !== <span class="hljs-number">-1</span> &amp;&amp; timeoutTime &lt;= currentTime) {
     <span class="hljs-comment">// 此帧已过期，且发生任务处理函数（执行具体任务，传入的回调）的超时</span>
     <span class="hljs-comment">// 需要执行任务处理，下文将调用；</span>
     frameDeadlineObject.didTimeout = <span class="hljs-literal">true</span>;
   } <span class="hljs-keyword">else</span> {
     <span class="hljs-comment">// 帧已过期，但没有发生任务处理函数的超时，暂时不调用任务处理函数</span>
     <span class="hljs-keyword">if</span> (!isAnimationFrameScheduled) {
       <span class="hljs-comment">// 当前没有调度别的帧回调函数</span>
       <span class="hljs-comment">// 调度下一帧</span>
       isAnimationFrameScheduled = <span class="hljs-literal">true</span>;
       requestAnimationFrame(animationTick);
     }
     <span class="hljs-comment">// Exit without invoking the callback.</span>
     <span class="hljs-keyword">return</span>;
   }
 } <span class="hljs-keyword">else</span> {
   <span class="hljs-comment">// 这一帧还有剩余时间</span>
   <span class="hljs-comment">// 标记未超时，之后调用任务处理函数</span>
   frameDeadlineObject.didTimeout = <span class="hljs-literal">false</span>;
 }

 <span class="hljs-comment">// 缓存的任务处理函数</span>
 timeoutTime = <span class="hljs-number">-1</span>;
 <span class="hljs-keyword">const</span> callback = scheduledRICCallback;
 scheduledRICCallback = <span class="hljs-literal">null</span>;
 <span class="hljs-keyword">if</span> (callback !== <span class="hljs-literal">null</span>) {
   <span class="hljs-comment">// 执行回调</span>
   callback(frameDeadlineObject);
 }
}

<span class="hljs-comment">// 自定义模拟requestIdleCallback</span>
rIC = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">
 callback: (deadline: Deadline</span>) =&gt; <span class="hljs-title">void</span>, // 传入的任务处理函数参数
 <span class="hljs-title">options</span>?: </span>{timeout: number} <span class="hljs-comment">// 其他参数</span>
) {
 <span class="hljs-comment">// 回调函数</span>
 scheduledRICCallback = callback;
 <span class="hljs-keyword">if</span> (options != <span class="hljs-literal">null</span> &amp;&amp; <span class="hljs-keyword">typeof</span> options.timeout === <span class="hljs-string">'number'</span>) {
   <span class="hljs-comment">// 计算过期时间</span>
   timeoutTime = now() + options.timeout;
 }
 <span class="hljs-keyword">if</span> (!isAnimationFrameScheduled) {
   <span class="hljs-comment">// 当前没有调度别的帧回调函数</span>
   isAnimationFrameScheduled = <span class="hljs-literal">true</span>;
   <span class="hljs-comment">// 初始开始执行帧回调 </span>
   requestAnimationFrame(animationTick);
 }
 <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
};
</code></pre>
<ol>
<li><code>frameDeadline</code>：是以启发法，从30fps（即30帧）开始调整得到的更适于当前环境的一帧限制时间；</li>
<li><code>timeRemaining</code>：计算<code>requestIdleCallback</code>此次空闲（帧）执行任务剩余时间，即距离deadline的时间；</li>
<li><code>options.timeout</code>：Fiber内部调用<code>rIC</code>API执行异步任务时，传递的任务到期时间参数；</li>
<li><code>frameDeadlineObject</code>：计算得到的某一帧可用时间对象，两个属性分别表示：
<ol>
<li>didTimeout：传入的异步任务  处理函数是否超时；</li>
<li>timeRemaining：当前帧可执行任务处理函数的剩余空闲时间；</li>
</ol>
</li>
<li><code>frameDeadlineObject</code>对象是基于传入的<code>timeout</code>参数和此模块内部自调整得到的<code>frameDeadline</code>参数计算得出；</li>
</ol>
</li>
</ol>
<h2><span id="Fiber">Fiber与组件</span></h2>
<p>我们已经知道了Fiber的功能及其主要特点，那么其如何和组件联系，并且如何实现效果的呢，以下几点可以概括：</p>
<ol>
<li>React应用中的基础单元是组件，应用以组件树形式组织，渲染组件；</li>
<li>Fiber调和器基础单元则是fiber（调和单元），应用以fiber树形式组织，应用Fiber算法；</li>
<li>组件树和fiber树结构对应，一个组件实例有一个对应的fiber实例；</li>
<li>Fiber负责整个应用层面的调和，fiber实例负责对应组件的调和；</li>
</ol>
<p><strong>注意Fiber与fiber的区别，Fiber是指调和器算法，fiber则是调和器算法组成单元，和组件与应用关系类似，每一个组件实例会有对应的fiber实例负责该组件的调和。</strong></p>
<h2><span id="Fiber-2">Fiber数据结构</span></h2>
<p>截止目前，我们对Fiber应该有了初步的了解，在具体介绍Fiber的实现与架构之前，准备先简单介绍一下Fiber的数据结构，数据结构能一定程度反映其整体工作架构。</p>
<p>其实，一个fiber就是一个JavaScript对象，以键值对形式存储了一个关联组件的信息，包括组件接收的props，维护的state，最后需要渲染出的内容等。接下来我们将介Fiber对象的主要属性。</p>
<h3><span id="Fiber-3">Fiber对象</span></h3>
<p>首先<a href="https://github.com/facebook/react/blob/master/packages/react-reconciler/src/ReactFiber.js">Fiber对象</a>的定义如下：</p>
<pre><code class="react hljs php"><span class="hljs-comment">// 一个Fiber对象作用于一个组件</span>
export type Fiber = {|
  <span class="hljs-comment">// 标记fiber类型tag.</span>
  tag: TypeOfWork,
  <span class="hljs-comment">// fiber对应的function/class/module类型组件名.</span>
  type: any,
  <span class="hljs-comment">// fiber所在组件树的根组件FiberRoot对象</span>
  stateNode: any,
  <span class="hljs-comment">// 处理完当前fiber后返回的fiber，</span>
  <span class="hljs-comment">// 返回当前fiber所在fiber树的父级fiber实例</span>
  <span class="hljs-keyword">return</span>: Fiber | <span class="hljs-keyword">null</span>,
  <span class="hljs-comment">// fiber树结构相关链接</span>
  child: Fiber | <span class="hljs-keyword">null</span>,
  sibling: Fiber | <span class="hljs-keyword">null</span>,
  index: number,

  <span class="hljs-comment">// 当前处理过程中的组件props对象</span>
  pendingProps: any, 
  <span class="hljs-comment">// 缓存的之前组件props对象</span>
  memoizedProps: any, <span class="hljs-comment">// The props used to create the output.</span>
  <span class="hljs-comment">// The state used to create the output</span>
  memoizedState: any,

  <span class="hljs-comment">// 组件状态更新及对应回调函数的存储队列</span>
  updateQueue: UpdateQueue&lt;any&gt; | <span class="hljs-keyword">null</span>,


  <span class="hljs-comment">// 描述当前fiber实例及其子fiber树的数位，</span>
  <span class="hljs-comment">// 如，AsyncUpdates特殊字表示默认以异步形式处理子树，</span>
  <span class="hljs-comment">// 一个fiber实例创建时，此属性继承自父级fiber，在创建时也可以修改值，</span>
  <span class="hljs-comment">// 但随后将不可修改。</span>
  internalContextTag: TypeOfInternalContext,

  <span class="hljs-comment">// 更新任务的最晚执行时间</span>
  expirationTime: ExpirationTime,

  <span class="hljs-comment">// fiber的版本池，即记录fiber更新过程，便于恢复</span>
  alternate: Fiber | <span class="hljs-keyword">null</span>,

  <span class="hljs-comment">// Conceptual aliases</span>
  <span class="hljs-comment">// workInProgress : Fiber -&gt;  alternate The alternate used for reuse happens</span>
  <span class="hljs-comment">// to be the same as work in progress.</span>
|};
</code></pre>
<ol>
<li>type &amp; key：同React元素的值；</li>
<li>type：描述fiber对应的React组件；
<ol>
<li>对于组合组件：值为function或class组件本身；</li>
<li>对于原生组件（div等）：值为该元素类型字符串；</li>
</ol>
</li>
<li>key：调和阶段，标识fiber，以检测是否可重用该fiber实例；</li>
<li>child &amp; sibling：组件树，对应生成fiber树，类比的关系；</li>
<li>pendingProps &amp; memoizedProps：分别表示组件当前传入的及之前的props；</li>
<li>return：返回当前fiber所在fiber树的父级fiber实例，即当前组件的父组件对应的fiber；</li>
<li>alternate：fiber的版本池，即记录fiber更新过程，便于恢复重用；</li>
<li>workInProgress：正在处理的fiber，概念上叫法，实际上没有此属性；</li>
</ol>
<h4><span id="alternate_fiber">alternate fiber</span></h4>
<p>可以理解为一个fiber版本池，用于交替记录组件更新（切分任务后变成多阶段更新）过程中fiber的更新，因为在组件更新的各阶段，更新前及更新过程中fiber状态并不一致，在需要恢复时（如，发生冲突），即可使用另一者直接回退至上一版本fiber。</p>
<blockquote>
<ol>
<li>使用alternate属性双向连接一个当前fiber和其work-in-progress，当前fiber实例的alternate属性指向其work-in-progress，work-in-progress的alternate属性指向当前稳定fiber；</li>
<li>当前fiber的替换版本是其work-in-progress，work-in-progress的交替版本是当前fiber；</li>
<li>当work-in-progress更新一次后，将同步至当前fiber，然后继续处理，同步直至任务完成；</li>
<li>work-in-progress指向处理过程中的fiber，而当前fiber总是维护处理完成的最新版本的fiber。</li>
</ol>
</blockquote>
<h4><span id="Fiber-4">创建Fiber实例</span></h4>
<p>创建fiber实例即返回一个带有上一小节描述的诸多属性的JavaScript对象，<code>FiberNode</code>即根据传入的参数构造返回一个初始化的对象：</p>
<pre><code class="react hljs javascript"><span class="hljs-keyword">var</span> createFiber = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">
  tag: TypeOfWork,
  key: null | string,
  internalContextTag: TypeOfInternalContext,
</span>) </span>{
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> FiberNode(tag, key, internalContextTag);
};
</code></pre>
<p>创建alternate fiber以处理任务的实现如下：</p>
<pre><code class="react hljs javascript"><span class="hljs-comment">// 创建一个alternate fiber处理任务</span>
<span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createWorkInProgress</span>(<span class="hljs-params">
  current: Fiber,
  pendingProps: any,
  expirationTime: ExpirationTime,
</span>) </span>{
  <span class="hljs-keyword">let</span> workInProgress = current.alternate;
  <span class="hljs-keyword">if</span> (workInProgress === <span class="hljs-literal">null</span>) {
    workInProgress = createFiber(
      current.tag,
      current.key,
      current.internalContextTag,
    );
    workInProgress.type = current.type;
    workInProgress.stateNode = current.stateNode;
    <span class="hljs-comment">// 形成alternate关系，互相交替模拟版本池</span>
    workInProgress.alternate = current;
    current.alternate = workInProgress;
  } 

  workInProgress.expirationTime = expirationTime;
  workInProgress.pendingProps = pendingProps;
  workInProgress.child = current.child;
  workInProgress.memoizedProps = current.memoizedProps;
  workInProgress.memoizedState = current.memoizedState;
  workInProgress.updateQueue = current.updateQueue;
  ...
  return workInProgress;
}
</code></pre>
<h3><span id="Fiber-5">Fiber类型</span></h3>
<p>上一小节，Fiber对象中有个<code>tag</code>属性，标记fiber类型，而fiber实例是和组件对应的，所以其类型基本上对应于组件类型，源码见<a href="https://github.com/facebook/react/blob/master/packages/shared/ReactTypeOfWork.js">ReactTypeOfWork模块</a>：</p>
<pre><code class="react hljs javascript"><span class="hljs-keyword">export</span> type TypeOfWork = <span class="hljs-number">0</span> | <span class="hljs-number">1</span> | <span class="hljs-number">2</span> | <span class="hljs-number">3</span> | <span class="hljs-number">4</span> | <span class="hljs-number">5</span> | <span class="hljs-number">6</span> | <span class="hljs-number">7</span> | <span class="hljs-number">8</span> | <span class="hljs-number">9</span> | <span class="hljs-number">10</span>;

<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> IndeterminateComponent = <span class="hljs-number">0</span>; <span class="hljs-comment">// 尚不知是类组件还是函数式组件</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> FunctionalComponent = <span class="hljs-number">1</span>; <span class="hljs-comment">// 函数式组件</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> ClassComponent = <span class="hljs-number">2</span>; <span class="hljs-comment">// Class类组件</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> HostRoot = <span class="hljs-number">3</span>; <span class="hljs-comment">// 组件树根组件，可以嵌套</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> HostPortal = <span class="hljs-number">4</span>; <span class="hljs-comment">// 子树. Could be an entry point to a different renderer.</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> HostComponent = <span class="hljs-number">5</span>; <span class="hljs-comment">// 标准组件，如地div， span等</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> HostText = <span class="hljs-number">6</span>; <span class="hljs-comment">// 文本</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> CallComponent = <span class="hljs-number">7</span>; <span class="hljs-comment">// 组件调用</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> CallHandlerPhase = <span class="hljs-number">8</span>; <span class="hljs-comment">// 调用组件方法</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> ReturnComponent = <span class="hljs-number">9</span>; <span class="hljs-comment">// placeholder（占位符）</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> Fragment = <span class="hljs-number">10</span>; <span class="hljs-comment">// 片段</span>
</code></pre>
<p>在调度执行任务的时候会根据不同类型fiber，即fiber.tag值进行不同处理。</p>
<h3><span id="FiberRoot">FiberRoot对象</span></h3>
<p><code>FiberRoot</code>对象，主要用来管理组件树组件的更新进程，同时记录组件树挂载的DOM容器相关信息，具体定义见<a href="https://github.com/facebook/react/blob/master/packages/react-reconciler/src/ReactFiberRoot.js">ReactFiberRoot模块</a>：</p>
<pre><code class="react hljs javascript"><span class="hljs-keyword">export</span> type FiberRoot = {
  <span class="hljs-comment">// fiber节点的容器元素相关信息，通常会直接传入容器元素</span>
  containerInfo: any,
  <span class="hljs-comment">// 当前fiber树中激活状态（正在处理）的fiber节点，</span>
  current: Fiber,
  <span class="hljs-comment">// 此节点剩余的任务到期时间</span>
  remainingExpirationTime: ExpirationTime,
  <span class="hljs-comment">// 更新是否可以提交</span>
  isReadyForCommit: boolean,
  <span class="hljs-comment">// 准备好提交的已处理完成的work-in-progress</span>
  finishedWork: Fiber | <span class="hljs-literal">null</span>,
  <span class="hljs-comment">// 多组件树FirberRoot对象以单链表存储链接，指向下一个需要调度的FiberRoot</span>
  nextScheduledRoot: FiberRoot | <span class="hljs-literal">null</span>,
};
</code></pre>
<h4><span id="FiberRoot-2">创建FiberRoot实例</span></h4>
<pre><code class="react hljs javascript"><span class="hljs-keyword">import</span> {
  ClassComponent,
  HostRoot
} <span class="hljs-keyword">from</span> <span class="hljs-string">'shared/ReactTypeOfWork'</span>;

<span class="hljs-comment">// 创建返回一个初始根组件对应的fiber实例</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createHostRootFiber</span>(<span class="hljs-params"></span>): <span class="hljs-title">Fiber</span> </span>{
  <span class="hljs-comment">// 创建fiber</span>
  <span class="hljs-keyword">const</span> fiber = createFiber(HostRoot, <span class="hljs-literal">null</span>, NoContext);
  <span class="hljs-keyword">return</span> fiber;
}

<span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createFiberRoot</span>(<span class="hljs-params">
  containerInfo: any,
  hydrate: boolean,
</span>) </span>{
  <span class="hljs-comment">// 创建初始根组件对应的fiber实例</span>
  <span class="hljs-keyword">const</span> uninitializedFiber = createHostRootFiber();
  <span class="hljs-comment">// 组件树根组件的FiberRoot对象</span>
  <span class="hljs-keyword">const</span> root = {
    <span class="hljs-comment">// 根组件对应的fiber实例</span>
    current: uninitializedFiber,
    <span class="hljs-attr">containerInfo</span>: containerInfo,
    <span class="hljs-attr">pendingChildren</span>: <span class="hljs-literal">null</span>,
    <span class="hljs-attr">remainingExpirationTime</span>: NoWork,
    <span class="hljs-attr">isReadyForCommit</span>: <span class="hljs-literal">false</span>,
    <span class="hljs-attr">finishedWork</span>: <span class="hljs-literal">null</span>,
    <span class="hljs-attr">context</span>: <span class="hljs-literal">null</span>,
    <span class="hljs-attr">pendingContext</span>: <span class="hljs-literal">null</span>,
    hydrate,
    <span class="hljs-attr">nextScheduledRoot</span>: <span class="hljs-literal">null</span>,
  };
  <span class="hljs-comment">// 组件树根组件fiber实例的stateNode指向FiberRoot对象</span>
  uninitializedFiber.stateNode = root;
  <span class="hljs-keyword">return</span> root;
}
</code></pre>
<h3><span id="ReactChildFiber">ReactChildFiber</span></h3>
<p>在生成组件树的FiberRoot对象后，会为子组件生成各自的fiber实例，这一部分由<a href="https://github.com/facebook/react/blob/master/packages/react-reconciler/src/ReactChildFiber.js">ReactChildFiber模块</a>实现：</p>
<pre><code class="react hljs javascript"><span class="hljs-comment">// 调和（处理更新）子fibers</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> reconcileChildFibers = ChildReconciler(<span class="hljs-literal">true</span>);
<span class="hljs-comment">// 挂载（初始化）子fibers</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> mountChildFibers = ChildReconciler(<span class="hljs-literal">false</span>);
</code></pre>
<p>而<code>ChildReconciler</code>方法所做的则是根据传入参数判断是调用初始化子组件fibers逻辑还是执行调和已有子组件fibers逻辑。</p>
<p><code>ChildReconciler</code>方法，返回<code>reconcileChildFibers</code>方法：</p>
<ol>
<li>判断子级传递内容的数据类型，执行不同的处理，这也对应着我们写React组件时传递<code>props.children</code>时，其类型可以是对象或数组，字符串，是数字等；</li>
<li>然后具体根据子组件类型，调用不同的具体调和处理函数；</li>
<li>最后返回根据子组件创建或更新得到的fiber实例；</li>
</ol>
<pre><code class="react hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">ChildReconciler</span>(<span class="hljs-params">a</span>) </span>{
  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">reconcileChildFibers</span>(<span class="hljs-params">
    returnFiber: Fiber, currentFirstChild: Fiber | null,
    newChild: any, expirationTime: ExpirationTime,
  </span>) </span>{
    <span class="hljs-comment">// Handle object types</span>
    <span class="hljs-keyword">const</span> isObject = <span class="hljs-keyword">typeof</span> newChild === <span class="hljs-string">'object'</span> &amp;&amp; newChild !== <span class="hljs-literal">null</span>;

    <span class="hljs-keyword">if</span> (isObject) {
      <span class="hljs-comment">// 子组件实例类型，以Symbol符号表示的</span>
      <span class="hljs-keyword">switch</span> (newChild.$$<span class="hljs-keyword">typeof</span>) {
        <span class="hljs-comment">// React Element</span>
        <span class="hljs-keyword">case</span> REACT_ELEMENT_TYPE:
          <span class="hljs-keyword">return</span> placeSingleChild(
            reconcileSingleElement(
              returnFiber, currentFirstChild,
              newChild, expirationTime
            )
          );
        <span class="hljs-comment">// React组件调用</span>
        <span class="hljs-keyword">case</span> REACT_CALL_TYPE:
          <span class="hljs-keyword">return</span> placeSingleChild(reconcileSingleCall(...));
        <span class="hljs-comment">// placeholder</span>
        <span class="hljs-keyword">case</span> REACT_RETURN_TYPE:
          <span class="hljs-keyword">return</span> ...;
        <span class="hljs-keyword">case</span> REACT_PORTAL_TYPE:
          <span class="hljs-keyword">return</span> ...;
      }
    }
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> newChild === <span class="hljs-string">'string'</span> || <span class="hljs-keyword">typeof</span> newChild === <span class="hljs-string">'number'</span>) {
      <span class="hljs-keyword">return</span> placeSingleChild(reconcileSingleTextNode(...));
    }
    <span class="hljs-keyword">if</span> (isArray(newChild)) {
      <span class="hljs-keyword">return</span> reconcileChildrenArray(...);
    }
    <span class="hljs-keyword">if</span> (getIteratorFn(newChild)) {
      <span class="hljs-keyword">return</span> reconcileChildrenIterator(...);
    }
    ...   
  }
}
</code></pre>
<h2><span id="Fiber-6">Fiber架构</span></h2>
<p>在学习Fiber的时候，我尝试去阅读源码，发现通过这种方式很难快速理解，学习Fiber，而先了解调和器是干什么的及调和器在React中的存在形式，然后再学习Fiber的结构及算法实现思路，明白从组件被定义到渲染至页面它需要做什么，这也是本篇文章的组织形式。</p>
<h3><span id="ExpirationTime_VS_PriorityLevel">优先级（ExpirationTime VS PriorityLevel）</span></h3>
<p>我们已经知道Fiber可以切分任务并设置不同优先级，那么是如何实现划分优先级的呢，其表现形式什么呢？</p>
<h4><span id="ExpirationTime">ExpirationTime</span></h4>
<p>Fiber切分任务并调用<code>requestIdleCallback</code>和<code>requestAnimationFrame</code>API，保证渲染任务和其他任务，在不影响应用交互，不掉帧的前提下，稳定执行，而实现调度的方式正是给每一个fiber实例设置到期执行时间，不同时间即代表不同优先级，到期时间越短，则代表优先级越高，需要尽早执行。</p>
<blockquote>
<p>所谓的到期时间（ExpirationTime），是相对于调度器初始调用的起始时间而言的一个时间段；调度器初始调用后的某一段时间内，需要调度完成这项更新，这个时间段长度值就是到期时间值。</p>
</blockquote>
<p>Fiber提供<a href="https://github.com/facebook/react/blob/master/packages/react-reconciler/src/ReactFiberExpirationTime.js">ReactFiberExpirationTime</a>模块实现到期时间的定义：</p>
<pre><code class="react hljs javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> NoWork = <span class="hljs-number">0</span>; <span class="hljs-comment">// 没有任务等待处理</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> Sync = <span class="hljs-number">1</span>; <span class="hljs-comment">// 同步模式，立即处理任务</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> Never = <span class="hljs-number">2147483647</span>; <span class="hljs-comment">// Max int32: Math.pow(2, 31) - 1</span>
<span class="hljs-keyword">const</span> UNIT_SIZE = <span class="hljs-number">10</span>; <span class="hljs-comment">// 过期时间单元（ms）</span>
<span class="hljs-keyword">const</span> MAGIC_NUMBER_OFFSET = <span class="hljs-number">2</span>; <span class="hljs-comment">// 到期时间偏移量</span>

<span class="hljs-comment">// 以ExpirationTime特定单位（1单位=10ms）表示的到期执行时间</span>
<span class="hljs-comment">// 1 unit of expiration time represents 10ms.</span>
<span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">msToExpirationTime</span> (<span class="hljs-params">ms</span>) </span>{
  <span class="hljs-comment">// 总是增加一个偏移量，在ms&lt;10时与Nowork模式进行区别</span>
  <span class="hljs-keyword">return</span> ((ms / UNIT_SIZE) | <span class="hljs-number">0</span>) + MAGIC_NUMBER_OFFSET;
}
<span class="hljs-comment">// 以毫秒表示的到期执行时间</span>
<span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">expirationTimeToMs</span>(<span class="hljs-params">expirationTime: ExpirationTime</span>) </span>{
  <span class="hljs-keyword">return</span> (expirationTime - MAGIC_NUMBER_OFFSET) * UNIT_SIZE;
}
<span class="hljs-comment">// 向上取整（整数单位到期执行时间）</span>
<span class="hljs-comment">// precision范围精度：弥补任务执行时间误差</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">ceiling</span>(<span class="hljs-params">num, precision</span>) </span>{
  <span class="hljs-keyword">return</span> (((num / precision) | <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>) * precision;
}

<span class="hljs-comment">// 计算处理误差时间在内的到期时间</span>
<span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">computeExpirationBucket</span>(<span class="hljs-params">currentTime, expirationInMs, bucketSizeMs,</span>) </span>{
  <span class="hljs-keyword">return</span> ceiling(
    currentTime + expirationInMs / UNIT_SIZE,
    bucketSizeMs / UNIT_SIZE
  );
}
</code></pre>
<p>该模块提供的功能主要有：</p>
<ol>
<li>Sync：同步模式，在UI线程立即执行此类任务，如动画反馈等；</li>
<li>异步模式：
<ol>
<li>转换：到期时间特定单位和时间单位（ms）的相互转换；</li>
<li>计算：计算包含允许误差在内的到期时间；</li>
</ol>
</li>
</ol>
<h4><span id="PriorityLevel">PriorityLevel</span></h4>
<p>其实在15.x版本中出现了对于任务的优先层级划分，<a href="https://github.com/facebook/react/blob/15.6-dev/src/renderers/shared/fiber/ReactPriorityLevel.js">ReactPriorityLevel模块</a>：</p>
<pre><code class="react hljs javascript"><span class="hljs-keyword">export</span> type PriorityLevel = <span class="hljs-number">0</span> | <span class="hljs-number">1</span> | <span class="hljs-number">2</span> | <span class="hljs-number">3</span> | <span class="hljs-number">4</span> | <span class="hljs-number">5</span>;

<span class="hljs-built_in">module</span>.exports = {
  <span class="hljs-attr">NoWork</span>: <span class="hljs-number">0</span>, <span class="hljs-comment">// No work is pending.</span>
  SynchronousPriority: <span class="hljs-number">1</span>, <span class="hljs-comment">// For controlled text inputs. Synchronous side-effects.</span>
  AnimationPriority: <span class="hljs-number">2</span>, <span class="hljs-comment">// Needs to complete before the next frame.</span>
  HighPriority: <span class="hljs-number">3</span>, <span class="hljs-comment">// Interaction that needs to complete pretty soon to feel responsive.</span>
  LowPriority: <span class="hljs-number">4</span>, <span class="hljs-comment">// Data fetching, or result from updating stores.</span>
  OffscreenPriority: <span class="hljs-number">5</span>, <span class="hljs-comment">// Won't be visible but do the work in case it becomes visible.</span>
};
</code></pre>
<p>相对于PriorityLevel的简单层级划分，在16.x版本中使用的则是ExpirationTime的到期时间方式表示任务的优先级，可以更好的对任务进行切分，调度。</p>
<h3><span id="Scheduler">调度器（Scheduler）</span></h3>
<p>前面介绍调和器主要作用就是在组件状态变更时，调用组件树各组件的<code>render</code>方法，渲染，卸载组件，而Fiber使得应用可以更好的协调不同任务的执行，调和器内关于高效协调的实现，我们可以称它为调度器（Scheduler）。</p>
<blockquote>
<p>顾名思义，调度器即调度资源以执行指定任务，React应用中应用组件的更新与渲染，需要占用系统CPU资源，如果不能很好的进行资源平衡，合理调度，优化任务执行策略，那很容易造成CPU这一紧缺资源的消耗和浪费，容易造成页面卡顿，动画掉帧，组件更新异常等诸多问题，就像城市交通调度一样，如果不能有效调度，交通状况很可能将拥堵不堪。</p>
</blockquote>
<p>在React 15.x版本中，组件的状态变更将直接导致其子组件树的重新渲染，新版本Fiber算法将在调度器方面进行全面改进，主要的关注点是：</p>
<ol>
<li>合并多次更新：没有必要在组件的每一个状态变更时都立即触发更新任务，有些中间状态变更其实是对更新任务所耗费资源的浪费，就比如用户发现错误点击时快速操作导致组件某状态从A至B再至C，这中间的B状态变更其实对于用户而言并没有意义，那么我们可以直接合并状态变更，直接从A至C只触发一次更新；</li>
<li>任务优先级：不同类型的更新有不同优先级，例如用户操作引起的交互动画可能需要有更好的体验，其优先级应该比完成数据更新高；</li>
<li>推拉式调度：基于推送的调度方式更多的需要开发者编码间接决定如何调度任务，而拉取式调度更方便React框架层直接进行全局自主调度；</li>
</ol>
<p><a href="https://github.com/facebook/react/blob/master/packages/react-reconciler/src/ReactFiberScheduler.js">传送查看源码</a></p>
<pre><code class="react hljs javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
  ...
  return {
    computeAsyncExpiration,
    computeExpirationForFiber,
    scheduleWork,
    batchedUpdates,
    unbatchedUpdates,
    flushSync,
    deferredUpdates,
  };
}
</code></pre>
<p>如上调度器主要输出API为实现调度任务，拉取更新，延迟更新等功能。</p>
<h4><span id="i-3">调度器与优先级</span></h4>
<p>调度器如何切分任务划分优先级的呢？在React调和算法中，任务由fiber实例描述，所以要划分任务优先级，等效于设置fiber的到期时间（expirationTime），调度器内提供了<code>computeExpirationForFiber</code>方法以计算某一个fiber的到期时间：</p>
<pre><code class="react hljs javascript"><span class="hljs-keyword">import</span> { 
  NoWork, Sync, Never, msToExpirationTime,
  expirationTimeToMs, computeExpirationBucket
} <span class="hljs-keyword">from</span> <span class="hljs-string">'./ReactFiberExpirationTime'</span>;

<span class="hljs-comment">// 表示下一个要处理的任务的到期时间，默认为NoWork，即当前没有正在等待执行的任务；</span>
<span class="hljs-comment">// Nowork默认更新策略：异步模式下，异步执行任务；同步模式下同步执行任务</span>
<span class="hljs-keyword">let</span> expirationContext = NoWork;
<span class="hljs-comment">// 下一次渲染到期时间</span>
<span class="hljs-keyword">let</span> nextRenderExpirationTime = NoWork;
<span class="hljs-comment">// 异步更新</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> AsyncUpdates = <span class="hljs-number">1</span>;
<span class="hljs-comment">// 初始时间（ms）.</span>
<span class="hljs-keyword">const</span> startTime = now();
<span class="hljs-comment">// ExpirationTime单位表示的当前时间（ExpirationTime单位，初始值传入0）</span>
<span class="hljs-keyword">let</span> mostRecentCurrentTime = msToExpirationTime(<span class="hljs-number">0</span>);

<span class="hljs-comment">// 计算fiber的到期时间</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">computeExpirationForFiber</span>(<span class="hljs-params">fiber</span>) </span>{
  <span class="hljs-keyword">let</span> expirationTime;

  <span class="hljs-keyword">if</span> (isWorking) {
    <span class="hljs-keyword">if</span> (isCommitting) {
      <span class="hljs-comment">// 在提交阶段的更新任务</span>
      <span class="hljs-comment">// 需要明确设置同步优先级（Sync Priority）</span>
      expirationTime = Sync;
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-comment">// 在渲染阶段发生的更新任务</span>
      <span class="hljs-comment">// 需要设置为下一次渲染时间的到期时间优先级</span>
      expirationTime = nextRenderExpirationTime;
    }
  } <span class="hljs-keyword">else</span> {
    <span class="hljs-comment">// 不在任务执行阶段，需要计算新的过期时间</span>

    <span class="hljs-comment">// 明确传递useSyncScheduling为true表明期望同步调用</span>
    <span class="hljs-comment">// 且fiber.internalContextTag != AsyncUpdates</span>
    <span class="hljs-keyword">if</span> (useSyncScheduling &amp;&amp; !(fiber.internalContextTag &amp; AsyncUpdates)) {
      <span class="hljs-comment">// 同步更新，设置为同步标记</span>
      expirationTime = Sync;
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-comment">// 异步更新，计算异步到期时间</span>
      expirationTime = computeAsyncExpiration();
    }
  }
  <span class="hljs-keyword">return</span> expirationTime;
}
</code></pre>
<ol>
<li>若当前处于任务提交阶段（更新提交至DOM渲染）时，设置当前fiber到期时间为<code>Sync</code>，即同步执行模式；</li>
<li>若处于DOM渲染阶段时，则需要延迟此fiber任务，将fiber到期时间设置为下一次DOM渲染到期时间；</li>
<li>若不在任务执行阶段，则需重新设置fiber到期时间：
<ol>
<li>若明确设置<code>useSyncScheduling</code>且<code>fiber.internalContextTag</code>值不等于<code>AsyncUpdates</code>，则表明是同步模式，设置为<code>Sync</code>；</li>
<li>否则，调用<code>computeAsyncExpiration</code>方法重新计算此fiber的到期时间；</li>
</ol>
</li>
</ol>
<pre><code class="react hljs javascript"><span class="hljs-comment">// 重新计算当前时间（ExpirationTime单位表示）</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">recalculateCurrentTime</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">const</span> ms = now() - startTime;
  <span class="hljs-comment">// ExpirationTime单位表示的当前时间</span>
  <span class="hljs-comment">// 时间段值为 now() - startTime（起始时间）</span>
  mostRecentCurrentTime = msToExpirationTime(ms);
  <span class="hljs-keyword">return</span> mostRecentCurrentTime;
}

<span class="hljs-comment">// 计算异步任务的到期时间</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">computeAsyncExpiration</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-comment">// 计算得到ExpirationTime单位的当前时间</span>
  <span class="hljs-comment">// 聚合相似的更新在一起</span>
  <span class="hljs-comment">// 更新应该在 ~1000ms，最多1200ms内完成</span>
  <span class="hljs-keyword">const</span> currentTime = recalculateCurrentTime();
  <span class="hljs-comment">// 对于每个fiber的期望到期时间的增值，最大值为1000ms</span>
  <span class="hljs-keyword">const</span> expirationMs = <span class="hljs-number">1000</span>;
  <span class="hljs-comment">// 到期时间的可接受误差时间，200ms</span>
  <span class="hljs-keyword">const</span> bucketSizeMs = <span class="hljs-number">200</span>;
  <span class="hljs-comment">// 返回包含误差时间在内的到期时间</span>
  <span class="hljs-keyword">return</span> computeExpirationBucket(currentTime, expirationMs, bucketSizeMs);
}
</code></pre>
<p>对于每一个fiber我们期望的到期时间参数是1000ms，另外由于任务执行时间误差，接受200ms误差，最后计算得到的到期时间默认返回值为ExpirationTime单位。</p>
<h4><span id="i-4">任务调度</span></h4>
<p>上一节介绍了调度器主要提供<code>computeExpirationForFiber</code>等方法支持计算任务优先级（到期时间），接下来介绍调度器如何调度任务。</p>
<blockquote>
<p>React应用更新时，Fiber从当前处理节点，层层遍历至组件树根组件，然后开始处理更新，调用前面的<code>requestIdleCallback</code>等API执行更新处理。</p>
</blockquote>
<p>主要调度逻辑实现在<code>scheduleWork</code>：</p>
<ol>
<li>通过<code>fiber.return</code>属性，从当前fiber实例层层遍历至组件树根组件；</li>
<li>依次对每一个fiber实例进行到期时间判断，若大于传入的期望任务到期时间参数，则将其更新为传入的任务到期时间；</li>
<li>调用<code>requestWork</code>方法开始处理任务，并传入获取的组件树根组件FiberRoot对象和任务到期时间；</li>
</ol>
<pre><code class="react hljs php"><span class="hljs-comment">// 调度任务</span>
<span class="hljs-comment">// expirationTime为期望的任务到期时间</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">scheduleWork</span><span class="hljs-params">(fiber, expirationTime: ExpirationTime)</span> </span>{
  <span class="hljs-keyword">return</span> scheduleWorkImpl(fiber, expirationTime, <span class="hljs-keyword">false</span>);
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">scheduleWorkImpl</span><span class="hljs-params">(
  fiber, expirationTime
)</span> </span>{
  let node = fiber;
  <span class="hljs-keyword">while</span> (node !== <span class="hljs-keyword">null</span>) {
    <span class="hljs-comment">// 向上遍历至根组件fiber实例，并依次更新expirationTime到期时间</span>
    <span class="hljs-keyword">if</span> (
      node.expirationTime === NoWork ||
      node.expirationTime &gt; expirationTime
    ) {
      <span class="hljs-comment">// 若fiber实例到期时间大于期望的任务到期时间，则更新fiber到期时间</span>
      node.expirationTime = expirationTime;
    }
    <span class="hljs-comment">// 同时更新alternate fiber的到期时间</span>
    <span class="hljs-keyword">if</span> (node.alternate !== <span class="hljs-keyword">null</span>) {
      <span class="hljs-keyword">if</span> (
        node.alternate.expirationTime === NoWork ||
        node.alternate.expirationTime &gt; expirationTime
      ) {
        <span class="hljs-comment">// 若alternate fiber到期时间大于期望的任务到期时间，则更新fiber到期时间</span>
        node.alternate.expirationTime = expirationTime;
      }
    }
    <span class="hljs-comment">// node.return为空，说明到达组件树顶部</span>
    <span class="hljs-keyword">if</span> (node.<span class="hljs-keyword">return</span> === <span class="hljs-keyword">null</span>) {
      <span class="hljs-keyword">if</span> (node.tag === HostRoot) {
        <span class="hljs-comment">// 确保是组件树根组件并获取FiberRoot实例</span>
        <span class="hljs-keyword">const</span> root = node.stateNode;
        <span class="hljs-comment">// 请求处理任务</span>
        requestWork(root, expirationTime);
      } <span class="hljs-keyword">else</span> {
        <span class="hljs-keyword">return</span>;
      }
    }
    <span class="hljs-comment">// 获取父级组件fiber实例</span>
    node = node.<span class="hljs-keyword">return</span>;
  }
}
</code></pre>
<p>处理任务的<code>requestWork</code>方法实现如下：</p>
<ol>
<li>首先比较任务剩余到期时间和期望的任务到期时间，若大于，则更新值；</li>
<li>判断任务期望到期时间（expirationTime），区分同步或异步执行任务；</li>
</ol>
<pre><code class="react hljs javascript"><span class="hljs-comment">// 当根节点发生更新时，调度器将调用requestWork方法开始任务处理过程</span>
<span class="hljs-comment">// It's up to the renderer to call renderRoot at some point in the future.</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">requestWork</span>(<span class="hljs-params">root: FiberRoot, expirationTime</span>) </span>{
  <span class="hljs-keyword">const</span> remainingExpirationTime = root.remainingExpirationTime;
  <span class="hljs-keyword">if</span> (remainingExpirationTime === NoWork ||
    expirationTime &lt; remainingExpirationTime) {
    <span class="hljs-comment">// 若任务剩余到期时间大于期望的任务到期时间，则需要更新</span>
    root.remainingExpirationTime = expirationTime;
  }

  <span class="hljs-keyword">if</span> (expirationTime === Sync) {
    <span class="hljs-comment">// 同步</span>
    performWork(Sync, <span class="hljs-literal">null</span>);
  } <span class="hljs-keyword">else</span> {
    <span class="hljs-comment">// 异步</span>
    scheduleCallbackWithExpiration(expirationTime);
  }
}
</code></pre>
<h3><span id="UpdateQueue">更新队列（UpdateQueue）</span></h3>
<p>我们知道如果需要实现组件的异步更新，肯定需要在更新前将更新任务进行存储，然后异步任务开始的时候读取更新并实现组件更新，存储更新任务就需要一个数据结构，最常见的就是栈和队列，Fiber的实现方式就是队列。</p>
<p>Fiber切分任务为多个任务单元（Work Unit）后，需要划分优先级然后存储在更新队列，随后按优先级进行调度执行。我们知道每一个组件都对应有一个fiber实例，fiber实例即负责管理调度组件的任务单元，所以需要为每一个组件fiber实例维护一个更新队列。</p>
<p>Fiber更新队列由<a href="https://github.com/facebook/react/blob/master/packages/react-reconciler/src/ReactFiberUpdateQueue.js">ReactFiberUpdateQueue模块</a>实现，主要涉及：</p>
<ol>
<li>创建更新队列；</li>
<li>添加更新至更新队列；</li>
<li>添加更新至fiber（即fiber实例对应的更新队列）；</li>
<li>处理更新队列中的更新并返回新状态对象：</li>
</ol>
<pre><code class="react hljs javascript"><span class="hljs-comment">// 一个更新对应的数据结构</span>
<span class="hljs-keyword">export</span> type Update&lt;State&gt; = {
  <span class="hljs-attr">expirationTime</span>: ExpirationTime,
  <span class="hljs-attr">partialState</span>: PartialState&lt;any, any&gt;,
  <span class="hljs-attr">callback</span>: Callback | <span class="hljs-literal">null</span>,
  <span class="hljs-attr">isReplace</span>: boolean,
  <span class="hljs-attr">isForced</span>: boolean,
  <span class="hljs-attr">next</span>: Update&lt;State&gt; | <span class="hljs-literal">null</span>,
};

<span class="hljs-comment">// 更新队列，以单链表形式表示并持久化</span>
<span class="hljs-comment">// 调度一个更新任务时，将其添加至当前（current）fiber和work-in-progress fiber的更新队列中;</span>
<span class="hljs-comment">// 这两个更新队列相互独立但共享同一个持久化数据结构；</span>
<span class="hljs-comment">// work-in-progress更新队列通常是current fiber更新队列的子集；</span>
<span class="hljs-comment">// 发生调和时，更新任务从work-in-progress fiber更新队列移除，</span>
<span class="hljs-comment">// current fiber内的更新任务则保留，当work-in-progress中断时可以从current fiber恢复；</span>
<span class="hljs-comment">// 提交完更新时，work-in-progress fiber就会变成current fiber</span>
<span class="hljs-keyword">export</span> type UpdateQueue&lt;State&gt; = {
  <span class="hljs-comment">// 若存在更早添加至队列的更新未被处理，</span>
  <span class="hljs-comment">// 则此已处理的更新并不会从队列中移除-先进先出原则</span>
  <span class="hljs-comment">// 所以需要维护baseState，代表第一个未处理的更新的基础状态，</span>
  <span class="hljs-comment">// 通常这就是队列中的第一个更新，因为在队列首部的已处理更新会被移除</span>
  baseState: State,
  <span class="hljs-comment">// 同理，需要维护最近的未处理的更新的到期时间，</span>
  <span class="hljs-comment">// 即未处理更新中到期时间值最小的</span>
  expirationTime: ExpirationTime,
  <span class="hljs-attr">first</span>: Update&lt;State&gt; | <span class="hljs-literal">null</span>,
  <span class="hljs-attr">last</span>: Update&lt;State&gt; | <span class="hljs-literal">null</span>,
  <span class="hljs-attr">callbackList</span>: <span class="hljs-built_in">Array</span>&lt;Update&lt;State&gt;&gt; | <span class="hljs-literal">null</span>,
  <span class="hljs-attr">hasForceUpdate</span>: boolean,
  <span class="hljs-attr">isInitialized</span>: boolean
};

<span class="hljs-comment">// 添加更新至更新队列</span>
<span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">insertUpdateIntoQueue</span>&lt;<span class="hljs-title">State</span>&gt;(<span class="hljs-params">
  queue: UpdateQueue&lt;State&gt;,
  update: Update&lt;State&gt;
</span>)</span>{
  <span class="hljs-comment">// 添加更新至队列尾部</span>
  <span class="hljs-keyword">if</span> (queue.last === <span class="hljs-literal">null</span>) {
    <span class="hljs-comment">// 队列为空</span>
    queue.first = queue.last = update;
  } <span class="hljs-keyword">else</span> {
    queue.last.next = update;
    queue.last = update;
  }
  <span class="hljs-keyword">if</span> (
    queue.expirationTime === NoWork ||
    queue.expirationTime &gt; update.expirationTime
  ) {
    <span class="hljs-comment">// 更新最近到期时间</span>
    queue.expirationTime = update.expirationTime;
  }
}
<span class="hljs-comment">// 添加更新至fiber实例</span>
<span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">insertUpdateIntoFiber</span>&lt;<span class="hljs-title">State</span>&gt;(<span class="hljs-params">
  fiber: Fiber,
  update: Update&lt;State&gt;,
</span>) </span>{
  <span class="hljs-comment">// 可以创建两个独立的更新队列</span>
  <span class="hljs-comment">// alternate主要用来保存更新过程中各版本更新队列，方便崩溃或冲突时回退</span>
  <span class="hljs-keyword">const</span> alternateFiber = fiber.alternate;
  <span class="hljs-keyword">let</span> queue1 = fiber.updateQueue;
  <span class="hljs-keyword">if</span> (queue1 === <span class="hljs-literal">null</span>) {
    <span class="hljs-comment">// 更新队列不存在，则创建一个空的更新队列</span>
    queue1 = fiber.updateQueue = createUpdateQueue((<span class="hljs-literal">null</span>));
  }

  <span class="hljs-keyword">let</span> queue2;
  <span class="hljs-keyword">if</span> (alternateFiber !== <span class="hljs-literal">null</span>) {
    <span class="hljs-comment">// alternate fiber实例存在，则需要为此</span>
    queue2 = alternateFiber.updateQueue;
    <span class="hljs-keyword">if</span> (queue2 === <span class="hljs-literal">null</span>) {
      queue2 = alternateFiber.updateQueue = createUpdateQueue((<span class="hljs-literal">null</span>: any));
    }
  } <span class="hljs-keyword">else</span> {
    queue2 = <span class="hljs-literal">null</span>;
  }
  queue2 = queue2 !== queue1 ? queue2 : <span class="hljs-literal">null</span>;

  <span class="hljs-comment">// 如果只存在一个更新队列</span>
  <span class="hljs-keyword">if</span> (queue2 === <span class="hljs-literal">null</span>) {
    insertUpdateIntoQueue(queue1, update);
    <span class="hljs-keyword">return</span>;
  }

  <span class="hljs-comment">// 如果任意更新队列为空，则需要将更新添加至两个更新队列</span>
  <span class="hljs-keyword">if</span> (queue1.last === <span class="hljs-literal">null</span> || queue2.last === <span class="hljs-literal">null</span>) {
    insertUpdateIntoQueue(queue1, update);
    insertUpdateIntoQueue(queue2, update);
    <span class="hljs-keyword">return</span>;
  }

  <span class="hljs-comment">// 如果2个更新队列均非空，则添加更新至第一个队列，并更新另一个队列的尾部更新项</span>
  insertUpdateIntoQueue(queue1, update);
  queue2.last = update;
}

<span class="hljs-comment">// 处理更新队列任务，返回新状态对象</span>
<span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">processUpdateQueue</span>&lt;<span class="hljs-title">State</span>&gt;(<span class="hljs-params">
  current, workInProgress, queue, instance, props,
  renderExpirationTime,
</span>) </span>{
  <span class="hljs-keyword">if</span> (current !== <span class="hljs-literal">null</span> &amp;&amp; current.updateQueue === queue) {
    <span class="hljs-comment">// 克隆current fiber以创建work-in-progress fiber</span>
    <span class="hljs-keyword">const</span> currentQueue = queue;
    queue = workInProgress.updateQueue = {
      <span class="hljs-attr">baseState</span>: currentQueue.baseState,
      <span class="hljs-attr">expirationTime</span>: currentQueue.expirationTime,
      <span class="hljs-attr">first</span>: currentQueue.first,
      <span class="hljs-attr">last</span>: currentQueue.last,
      <span class="hljs-attr">isInitialized</span>: currentQueue.isInitialized,
      <span class="hljs-comment">// These fields are no longer valid because they were already committed. Reset them.</span>
      callbackList: <span class="hljs-literal">null</span>,
      <span class="hljs-attr">hasForceUpdate</span>: <span class="hljs-literal">false</span>,
    };
  }

  <span class="hljs-comment">// Reset the remaining expiration time. If we skip over any updates, we'll</span>
  <span class="hljs-comment">// increase this accordingly.</span>
  queue.expirationTime = NoWork;

  <span class="hljs-keyword">let</span> dontMutatePrevState = <span class="hljs-literal">true</span>;
  <span class="hljs-keyword">let</span> update = queue.first;
  <span class="hljs-keyword">let</span> didSkip = <span class="hljs-literal">false</span>;
  <span class="hljs-keyword">while</span> (update !== <span class="hljs-literal">null</span>) {
    <span class="hljs-keyword">const</span> updateExpirationTime = update.expirationTime;
    <span class="hljs-keyword">if</span> (updateExpirationTime &gt; renderExpirationTime) {
      <span class="hljs-comment">// 此更新优先级不够，不处理，跳过</span>
      <span class="hljs-keyword">if</span> (queue.expirationTime === NoWork ||
          queue.expirationTime &gt; updateExpirationTime
         ) {
        <span class="hljs-comment">// 重新设置最近未处理更新的到期时间</span>
        queue.expirationTime = updateExpirationTime;
      }
      update = update.next;
      <span class="hljs-keyword">continue</span>;
    }

    <span class="hljs-comment">// 优先级足够，处理</span>
    <span class="hljs-keyword">let</span> partialState;
    <span class="hljs-keyword">if</span> (update.isReplace) {
      <span class="hljs-comment">// 使用replaceState()直接替换状态对象方式更新时</span>
      <span class="hljs-comment">// 获取新状态对象</span>
      state = getStateFromUpdate(update, instance, state, props);
      <span class="hljs-comment">// 不需要合并至之前状态对象，标记为true</span>
      dontMutatePrevState = <span class="hljs-literal">true</span>;
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-comment">// 更新部分状态方式</span>
      <span class="hljs-comment">// 获取更新部分状态时的状态对象</span>
      partialState = getStateFromUpdate(update, instance, state, props);
      <span class="hljs-keyword">if</span> (partialState) {
        <span class="hljs-keyword">if</span> (dontMutatePrevState) {
          <span class="hljs-comment">// 上一次是替换状态，所以不能影响state</span>
          state = <span class="hljs-built_in">Object</span>.assign({}, state, partialState);
        } <span class="hljs-keyword">else</span> {
          <span class="hljs-comment">// 更新部分状态，直接将新状态合并至上一次状态</span>
          state = <span class="hljs-built_in">Object</span>.assign(state, partialState);
        }
        <span class="hljs-comment">// 重置标记为false</span>
        dontMutatePrevState = <span class="hljs-literal">false</span>;
      }
    }
    <span class="hljs-comment">// 强制立即更新</span>
    <span class="hljs-keyword">if</span> (update.isForced) {
      queue.hasForceUpdate = <span class="hljs-literal">true</span>;
    }
    <span class="hljs-comment">// 添加回调函数</span>
    <span class="hljs-keyword">if</span> (update.callback !== <span class="hljs-literal">null</span>) {
      <span class="hljs-comment">// Append to list of callbacks.</span>
      <span class="hljs-keyword">let</span> callbackList = queue.callbackList;
      <span class="hljs-keyword">if</span> (callbackList === <span class="hljs-literal">null</span>) {
        callbackList = queue.callbackList = [];
      }
      callbackList.push(update);
    }
    <span class="hljs-comment">// 遍历下一个更新任务</span>
    update = update.next;
  }
  <span class="hljs-comment">// 返回最新的状态对象</span>
  <span class="hljs-keyword">return</span> state;
}
</code></pre>
<h3><span id="Updater">更新器（Updater）</span></h3>
<p>调度器协调，调度的任务主要就是执行组件或组件树更新，而这些任务则具体由更新器（Updater）完成，可以说调度器是在整个应用组件树层面掌控全局，而更新器则深入到个更具体的每一个组件内部执行。</p>
<p>每一个组件实例化时都会被注入一个更新器，负责协调组件与React核心进程的通信，其职责主要可以概括为以下几点：</p>
<ol>
<li>找到组件实例对应的fiber实例；</li>
<li>询问调度器当前组件fiber实例的优先级；</li>
<li>将更新推入fiber的更新队列；</li>
<li>根据优先级调度更新任务；</li>
</ol>
<p>更新器实现见<a href="https://github.com/facebook/react/blob/master/packages/react-reconciler/src/ReactFiberClassComponent.js">ReactFiberClassComponent模块</a>：</p>
<pre><code class="react hljs javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">
  scheduleWork: (fiber: Fiber, expirationTime: ExpirationTime</span>) =&gt; <span class="hljs-title">void</span>,
  <span class="hljs-title">computeExpirationForFiber</span>: (<span class="hljs-params">fiber: Fiber</span>) =&gt; <span class="hljs-title">ExpirationTime</span>,
  <span class="hljs-title">memoizeProps</span>: (<span class="hljs-params">workInProgress: Fiber, props: any</span>) =&gt; <span class="hljs-title">void</span>,
  <span class="hljs-title">memoizeState</span>: (<span class="hljs-params">workInProgress: Fiber, state: any</span>) =&gt; <span class="hljs-title">void</span>,
) </span>{
  <span class="hljs-comment">// Class component state updater</span>
  <span class="hljs-keyword">const</span> updater = {
    isMounted,
    <span class="hljs-comment">// 状态变更，更新入队列</span>
    enqueueSetState(instance, partialState, callback) {
      <span class="hljs-comment">// 获取fiber</span>
      <span class="hljs-keyword">const</span> fiber = ReactInstanceMap.get(instance);
      <span class="hljs-keyword">const</span> expirationTime = computeExpirationForFiber(fiber);
      <span class="hljs-comment">// 创建更新任务</span>
      <span class="hljs-keyword">const</span> update = {
        expirationTime,
        partialState,
        callback,
        <span class="hljs-attr">isReplace</span>: <span class="hljs-literal">false</span>,
        <span class="hljs-attr">isForced</span>: <span class="hljs-literal">false</span>,
        <span class="hljs-attr">nextCallback</span>: <span class="hljs-literal">null</span>,
        <span class="hljs-attr">next</span>: <span class="hljs-literal">null</span>,
      };
      <span class="hljs-comment">// 添加更新任务至fiber</span>
      insertUpdateIntoFiber(fiber, update);
      <span class="hljs-comment">// 调用调度器API以调度fiber任务</span>
      scheduleWork(fiber, expirationTime);
    },
    <span class="hljs-comment">// 替换状态时</span>
    enqueueReplaceState(instance, state, callback) {
      <span class="hljs-keyword">const</span> fiber = ReactInstanceMap.get(instance);
      <span class="hljs-keyword">const</span> expirationTime = computeExpirationForFiber(fiber);
      <span class="hljs-keyword">const</span> update = {
        expirationTime,
        <span class="hljs-attr">partialState</span>: state,
        callback,
        <span class="hljs-attr">isReplace</span>: <span class="hljs-literal">true</span>,
        <span class="hljs-attr">isForced</span>: <span class="hljs-literal">false</span>,
        <span class="hljs-attr">nextCallback</span>: <span class="hljs-literal">null</span>,
        <span class="hljs-attr">next</span>: <span class="hljs-literal">null</span>,
      };
      <span class="hljs-comment">// 添加更新任务至fiber</span>
      insertUpdateIntoFiber(fiber, update);
      scheduleWork(fiber, expirationTime);
    },
    <span class="hljs-comment">// 强制更新</span>
    enqueueForceUpdate(instance, callback) {
      <span class="hljs-keyword">const</span> fiber = ReactInstanceMap.get(instance);
      <span class="hljs-keyword">const</span> expirationTime = computeExpirationForFiber(fiber);
      <span class="hljs-keyword">const</span> update = {
        expirationTime,
        <span class="hljs-attr">partialState</span>: <span class="hljs-literal">null</span>,
        callback,
        <span class="hljs-attr">isReplace</span>: <span class="hljs-literal">false</span>,
        <span class="hljs-attr">isForced</span>: <span class="hljs-literal">true</span>,
        <span class="hljs-attr">nextCallback</span>: <span class="hljs-literal">null</span>,
        <span class="hljs-attr">next</span>: <span class="hljs-literal">null</span>,
      };
      insertUpdateIntoFiber(fiber, update);
      scheduleWork(fiber, expirationTime);
    },
  };

  <span class="hljs-comment">// 调用组件实例生命周期方法并调用更新器API</span>
  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">callComponentWillReceiveProps</span>(<span class="hljs-params">
    workInProgress, instance, newProps, newContext
  </span>) </span>{
    <span class="hljs-keyword">const</span> oldState = instance.state;
    instance.componentWillReceiveProps(newProps, newContext);

    <span class="hljs-keyword">if</span> (instance.state !== oldState) {
      <span class="hljs-comment">// 调用更新器入队列方法</span>
      updater.enqueueReplaceState(instance, instance.state, <span class="hljs-literal">null</span>);
    }
  }

  <span class="hljs-comment">// 设置Class组件实例的更新器和fiber</span>
  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">adoptClassInstance</span>(<span class="hljs-params">workInProgress, instance</span>): </span>{
    <span class="hljs-comment">// 设置更新器</span>
    instance.updater = updater;
    workInProgress.stateNode = instance;
    <span class="hljs-comment">// 设置fiber</span>
    ReactInstanceMap.set(instance, workInProgress);
  }

  <span class="hljs-comment">// 实例化Class组件实例</span>
  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">constructClassInstance</span>(<span class="hljs-params">workInProgress, props</span>) </span>{
    <span class="hljs-keyword">const</span> ctor = workInProgress.type;
    <span class="hljs-keyword">const</span> unmaskedContext = getUnmaskedContext(workInProgress);
    <span class="hljs-keyword">const</span> needsContext = isContextConsumer(workInProgress);
    <span class="hljs-keyword">const</span> context = needsContext
    ? getMaskedContext(workInProgress, unmaskedContext)
    : emptyObject;
    <span class="hljs-comment">// 实例化组件类型</span>
    <span class="hljs-keyword">const</span> instance = <span class="hljs-keyword">new</span> ctor(props, context);
    <span class="hljs-comment">// 设置Class实例的更新器和fiber</span>
    adoptClassInstance(workInProgress, instance);

    <span class="hljs-keyword">return</span> instance;
  }

  <span class="hljs-comment">// 挂载组件实例</span>
  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">mountClassInstance</span>(<span class="hljs-params">
    workInProgress, renderExpirationTime</span>) </span>{
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> instance.componentWillMount === <span class="hljs-string">'function'</span>) {
      callComponentWillMount(workInProgress, instance);
    }
  }

 <span class="hljs-comment">// 更新组件实例 </span>
  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">updateClassInstance</span>(<span class="hljs-params">
    current, workInProgress, renderExpirationTime
  </span>) </span>{
    <span class="hljs-comment">// 组件实例</span>
    <span class="hljs-keyword">const</span> instance = workInProgress.stateNode;
    <span class="hljs-comment">// 原Props或新Props</span>
    <span class="hljs-keyword">const</span> oldProps = workInProgress.memoizedProps;
    <span class="hljs-keyword">let</span> newProps = workInProgress.pendingProps;
    <span class="hljs-keyword">if</span> (!newProps) {
      <span class="hljs-comment">// 没有新Props则直接使用原Props</span>
      newProps = oldProps;
    }

    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> instance.componentWillReceiveProps === <span class="hljs-string">'function'</span> &amp;&amp;
      (oldProps !== newProps)) {
      <span class="hljs-comment">// 调用方法进行更新器相关处理</span>
      callComponentWillReceiveProps(
        workInProgress, instance, newProps
      );
    }

    <span class="hljs-comment">// 根据原状态对象和更新队列计算得到新状态对象</span>
    <span class="hljs-keyword">const</span> oldState = workInProgress.memoizedState;
    <span class="hljs-keyword">let</span> newState;
    <span class="hljs-keyword">if</span> (workInProgress.updateQueue !== <span class="hljs-literal">null</span>) {
      <span class="hljs-comment">// 处理更新队列更新，计算得到新State对象</span>
      newState = processUpdateQueue(
        current,
        workInProgress,
        workInProgress.updateQueue,
        instance,
        newProps,
        renderExpirationTime,
      );
    } <span class="hljs-keyword">else</span> {
      newState = oldState;
    }

    <span class="hljs-comment">// 检查是否需要更新组件</span>
    <span class="hljs-keyword">const</span> shouldUpdate = checkShouldComponentUpdate(...);

    <span class="hljs-keyword">if</span> (shouldUpdate) {
      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> instance.componentWillUpdate === <span class="hljs-string">'function'</span>) {      
        instance.componentWillUpdate(newProps, newState, newContext);      
      }
    }
    <span class="hljs-comment">// 调用生命周期方法</span>
    ...
    return shouldUpdate;
  }

  <span class="hljs-keyword">return</span> {
    adoptClassInstance,
    constructClassInstance,
    mountClassInstance,
    updateClassInstance
  };
}
</code></pre>
<p>主要实现以下几个功能：</p>
<ol>
<li>
<p>初始化组件实例并为其设置fibre实例和更新器；</p>
</li>
<li>
<p>初始化或更新组件实例，根据更新队列计算得到新状态等；</p>
</li>
<li>
<p>调用组件实例生命周期方法，并且调用更新器API更新fiber实例等，如更新组件实例调用的<code>callComponentWillReceiveProps</code>方法，该方法调用组件实例的<code>componentWillReceiveProps</code>生命周期方法，并调用更新器<code>updater.enqueueReplaceState</code>方法，更新fiber实例，并将更新添加至更新队列:</p>
<pre><code class="react hljs javascript"><span class="hljs-comment">// 调用组件实例生命周期方法并调用更新器API</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">callComponentWillReceiveProps</span>(<span class="hljs-params">
workInProgress, instance, newProps, newContext
</span>) </span>{
 <span class="hljs-keyword">const</span> oldState = instance.state;
 instance.componentWillReceiveProps(newProps, newContext);

 <span class="hljs-keyword">if</span> (instance.state !== oldState) {
   <span class="hljs-comment">// 调用更新器入队列方法</span>
   updater.enqueueReplaceState(instance, instance.state, <span class="hljs-literal">null</span>);
 }
}
</code></pre>
<p>​</p>
</li>
</ol>
<p>另外需要重点关注的是<code>insertUpdateIntoFiber</code>方法，该方法实现将更新任务添加至组件fiber实例，内部会处理将任务添加至fiber更新队列，源码见上文更新队列中介绍的<a href="https://github.com/facebook/react/blob/master/packages/react-reconciler/src/ReactFiberUpdateQueue.js">ReactFiberUpdateQueue模块</a>，最终还是调用<code>insertUpdateIntoQueue</code>。</p>
<h4><span id="fiber">获取fiber实例</span></h4>
<p>获取fiber实例比较简单，fiber实例通过<a href="https://github.com/facebook/react/blob/master/packages/shared/ReactInstanceMap.js"><code>ReactInstanceMap</code>模块</a>提供的API进行维护：</p>
<pre><code class="react hljs javascript"><span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">get</span>(<span class="hljs-params">key</span>) </span>{
  <span class="hljs-keyword">return</span> key._reactInternalFiber;
}
<span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">set</span>(<span class="hljs-params">key, value</span>) </span>{
  key._reactInternalFiber = value;
}
</code></pre>
<p>使用节点上的<code>_reactInternalFiber</code>属性维护fiber实例，调用<code>get</code>方法即可获取。</p>
<h4><span id="i-5">获取优先级</span></h4>
<p>fiber实例的优先级是由调度器控制，所以需要询问调度器关于当前fiber实例的优先级，调度器提供<code>computeExpirationForFiber</code>获取特定fiber实例的优先级，即获取特点fiber实例的到期时间（expirationTime），方法具体实现见调度器与优先级章节。</p>
<h4><span id="i-6">将更新任务添加至更新队列</span></h4>
<p>组件状态变更时，将对应的组件更新任务划分优先级并根据优先级从高到低依次推入fiber实例的更新队列，诸如使用<code>setState</code>方法触发的更新任务通常是添加至更新队列尾部。</p>
<p>调度器完成切分任务为任务单元后，将使用<code>performUnitOfWork</code>方法开始处理任务单元，然后按调用组件的更新器（实现见上文介绍）相关API，按优先级将任务单元添加至fiber实例的更新队列：</p>
<ol>
<li>
<p>从work-in-progress的alternate属性获取当前稳定fiber，然后调用<code>beginWork</code>开始处理更新；</p>
<pre><code class="react hljs javascript"><span class="hljs-comment">// 处理任务单元</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">performUnitOfWork</span>(<span class="hljs-params">workInProgress: Fiber</span>): <span class="hljs-title">Fiber</span> | <span class="hljs-title">null</span> </span>{
 <span class="hljs-comment">// 当前最新版本fiber实例使用fiber的alternate属性获取</span>
 <span class="hljs-keyword">const</span> current = workInProgress.alternate;
 <span class="hljs-comment">// 开始处理，返回子组件fiber实例</span>
 <span class="hljs-keyword">let</span> next = beginWork(current, workInProgress, nextRenderExpirationTime);
 <span class="hljs-keyword">if</span> (next === <span class="hljs-literal">null</span>) {
   <span class="hljs-comment">// 不存在子级fiber，完成单元任务的处理，之后继续处理下一个任务</span>
   next = completeUnitOfWork(workInProgress);
 }
 <span class="hljs-keyword">return</span> next;
}
</code></pre>
<p>​</p>
</li>
<li>
<p><code>beginWork</code>返回传入fiber实例的子组件fiber实例，，若为空，则代表此组件树任务处理完成，否则会在<code>workLoop</code> 方法内迭代调用<code>performUnitOfWork</code>方法处理：</p>
<ol>
<li><code>deadline</code>：是调用<code>requestIdleCallback</code>API执行任务处理函数时返回的帧时间对象；</li>
<li><code>nextUnitOfWork</code>：下一个要处理的任务单元；</li>
<li><code>shouldYield</code>：判断是否暂停当前任务处理过程；</li>
</ol>
<pre><code class="react hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">workLoop</span>(<span class="hljs-params">expirationTime</span>) </span>{
 <span class="hljs-comment">// 渲染更新至DOM的到期时间值 小于 调度开始至开始处理此fiber的时间段值</span>
 <span class="hljs-comment">// 说明任务已经过期</span>
 <span class="hljs-keyword">if</span> (nextRenderExpirationTime &lt;= mostRecentCurrentTime) {
   <span class="hljs-comment">// Flush all expired work， 处理所有已经到期的更新</span>
   <span class="hljs-keyword">while</span> (nextUnitOfWork !== <span class="hljs-literal">null</span>) {
     nextUnitOfWork = performUnitOfWork(nextUnitOfWork);
   }
 } <span class="hljs-keyword">else</span> {
   <span class="hljs-comment">// Flush asynchronous work until the deadline runs out of time.</span>
   <span class="hljs-comment">// 依次处理异步更新，直至deadline到达</span>
   <span class="hljs-keyword">while</span> (nextUnitOfWork !== <span class="hljs-literal">null</span> &amp;&amp; !shouldYield()) {
     nextUnitOfWork = performUnitOfWork(nextUnitOfWork);
   }
 }
}
<span class="hljs-comment">// 处理异步任务时, 调和器将询问渲染器是否暂停执行；</span>
<span class="hljs-comment">// 在DOM中，使用requestIdleCallback API实现</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">shouldYield</span>(<span class="hljs-params"></span>) </span>{
 <span class="hljs-keyword">if</span> (deadline === <span class="hljs-literal">null</span>) {
   <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
 }
 <span class="hljs-keyword">if</span> (deadline.timeRemaining() &gt; <span class="hljs-number">1</span>) {
   <span class="hljs-comment">// 这一帧帧还有剩余时间，不需要暂停;</span>
   <span class="hljs-comment">// 只有非过期任务可以到达此判断条件</span>
   <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
 }
 deadlineDidExpire = <span class="hljs-literal">true</span>;
 <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
}
</code></pre>
<p>​</p>
</li>
<li>
<p><code>beginWork</code>方法内根据组件类型调用不同方法，这些方法内调用更新器API将更新添加至更新队列，具体实现见<a href="https://github.com/facebook/react/blob/master/packages/react-reconciler/src/ReactFiberBeginWork.js">ReactFiberBeginWork模块</a>:</p>
<pre><code class="react hljs php"><span class="hljs-comment">// 引入更新器模块</span>
import ReactFiberClassComponent from <span class="hljs-string">'./ReactFiberClassComponent'</span>;

export <span class="hljs-keyword">default</span> <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(
 config, hostContext, hydrationContext,
 scheduleWork: <span class="hljs-params">(fiber: Fiber, expirationTime: ExpirationTime)</span> =&gt; void,
 computeExpirationForFiber: <span class="hljs-params">(fiber: Fiber)</span> =&gt; ExpirationTime,
)</span> </span>{
 <span class="hljs-comment">// 初始化更新器模块，获取API</span>
 <span class="hljs-keyword">const</span> {
   adoptClassInstance, constructClassInstance,
   mountClassInstance, updateClassInstance
 } = ReactFiberClassComponent(
   scheduleWork, computeExpirationForFiber,
   memoizeProps, memoizeState
 );

 <span class="hljs-comment">// beginWork，开始任务处理</span>
 <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">beginWork</span><span class="hljs-params">(
   current, workInProgress, renderExpirationTime
 )</span> </span>{
   <span class="hljs-keyword">switch</span> (workInProgress.tag) {
     <span class="hljs-comment">// 对应不同类型fiber，执行不同处理逻辑</span>
     <span class="hljs-keyword">case</span> IndeterminateComponent:
       ...
     <span class="hljs-keyword">case</span> FunctionalComponent:
       <span class="hljs-keyword">return</span> updateFunctionalComponent(current, workInProgress);
     <span class="hljs-keyword">case</span> ClassComponent:
       <span class="hljs-comment">// 更新类组件，返回子级fiber实例</span>
       <span class="hljs-keyword">return</span> updateClassComponent(
         current, workInProgress, renderExpirationTime
       );
     <span class="hljs-keyword">case</span> HostRoot:
       <span class="hljs-keyword">return</span> updateHostRoot(current, workInProgress, renderExpirationTime);
     <span class="hljs-keyword">case</span> HostComponent:
       ...
     <span class="hljs-keyword">case</span> HostText:
       <span class="hljs-keyword">return</span> updateHostText(current, workInProgress);
     <span class="hljs-keyword">case</span> CallHandlerPhase:
       <span class="hljs-comment">// This is a restart. Reset the tag to the initial phase.</span>
       workInProgress.tag = CallComponent;
     <span class="hljs-keyword">case</span> CallComponent:
       ...
     <span class="hljs-keyword">case</span> ReturnComponent:
       <span class="hljs-comment">// A return component is just a placeholder, we can just run through the</span>
       <span class="hljs-comment">// next one immediately.</span>
       <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;
     <span class="hljs-keyword">case</span> HostPortal:
       ...
     <span class="hljs-keyword">case</span> Fragment:
       <span class="hljs-keyword">return</span> updateFragment(current, workInProgress);
     <span class="hljs-keyword">default</span>:;
   }
 }

 <span class="hljs-keyword">return</span> {
   beginWork,
   beginFailedWork
 };
}
</code></pre>
<ol>
<li>
<p>引入<code>ReactFiberClassComponent</code>更新器相关模块并初始化获得API；</p>
</li>
<li>
<p><code>beginWork</code>方法内根据传入的work-in-progress的fiber类型（tag）调用不同逻辑处理；</p>
</li>
<li>
<p>在逻辑处理里面会调用更新期API，将更新添加至更新队列；</p>
</li>
<li>
<p>以<code>ClassComponent</code>为例，将调用<code>updateClassComponent</code>方法：</p>
<ol>
<li>
<p>判断若第一次则初始化并挂载组件实例，否则调用<code>updateClassInstance</code>方法更新组件实例；</p>
</li>
<li>
<p>最后调用<code>finishClassComponent</code>方法，调和处理其子组件并返回其子级fiber实例；</p>
<pre><code class="react hljs javascript"><span class="hljs-comment">// 更新类组件</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">updateClassComponent</span>(<span class="hljs-params">
current, workInProgress, renderExpirationTime
</span>) </span>{
<span class="hljs-keyword">let</span> shouldUpdate;
<span class="hljs-keyword">if</span> (current === <span class="hljs-literal">null</span>) {
 <span class="hljs-keyword">if</span> (!workInProgress.stateNode) {
   <span class="hljs-comment">// fiber没有组件实例时需要初始化组件实例</span>
   constructClassInstance(workInProgress, workInProgress.pendingProps);
   <span class="hljs-comment">// 挂载组件实例</span>
   mountClassInstance(workInProgress, renderExpirationTime);
   <span class="hljs-comment">// 默认需要更新</span>
   shouldUpdate = <span class="hljs-literal">true</span>;
 }
} <span class="hljs-keyword">else</span> {
 <span class="hljs-comment">// 处理实例更新并返回是否需要更新组件</span>
 shouldUpdate = updateClassInstance(
   current,
   workInProgress,
   renderExpirationTime,
 );
}
<span class="hljs-comment">// 更新完成后，返回子组件fiber实例</span>
<span class="hljs-keyword">return</span> finishClassComponent(
 current, workInProgress, shouldUpdate, hasContext
);
}

<span class="hljs-comment">// 类组件更新完成</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">finishClassComponent</span>(<span class="hljs-params">
current, workInProgress, shouldUpdate, hasContext
</span>) </span>{
<span class="hljs-keyword">if</span> (!shouldUpdate) {
 <span class="hljs-comment">// 明确设置不需要更新时，不处理更新，</span>
 <span class="hljs-comment">// 如shouldCOmponentUpdate方法return false</span>
 <span class="hljs-keyword">return</span> bailoutOnAlreadyFinishedWork(current, workInProgress);
}

<span class="hljs-keyword">const</span> instance = workInProgress.stateNode;
<span class="hljs-comment">// 重新渲染</span>
ReactCurrentOwner.current = workInProgress;
<span class="hljs-comment">// 返回组件子组件树等内容</span>
<span class="hljs-keyword">let</span> nextChildren = instance.render();
<span class="hljs-comment">// 调和子组件树，将迭代处理每一个组件</span>
<span class="hljs-comment">// 函数内将调用ReactChildFiber模块提供的API</span>
reconcileChildren(current, workInProgress, nextChildren);
<span class="hljs-comment">// 返回子组件fiber实例</span>
<span class="hljs-keyword">return</span> workInProgress.child;
}
</code></pre>
</li>
</ol>
</li>
</ol>
</li>
</ol>
<h4><span id="i-7">调度更新任务</span></h4>
<p>上一节更新器已经能按照优先级将更新添加至更新队列，那么如何调度执行更新任务呢？</p>
<p>在更新器实现<a href="https://github.com/facebook/react/blob/master/packages/react-reconciler/src/ReactFiberClassComponent.js">ReactFiberClassComponent模块</a>中，在<code>enqueueSetState</code>，<code>enqueueReplaceState</code>和<code>enqueueForceUpdate</code>入队列方法中，均会调用如下方法：</p>
<pre><code class="react hljs sql">insertUpdateIntoFiber(fiber, <span class="hljs-keyword">update</span>);
scheduleWork(fiber, expirationTime);
</code></pre>
<ol>
<li><code>insertUpdateIntoFiber</code>：将更新添加至fiber实例，最终会添加至更新队列；</li>
<li><code>scheduleWork</code>：调度任务，传入fiber实例和任务到期时间；</li>
</ol>
<h2><span id="i-8">渲染与调和</span></h2>
<p>在调和阶段，不涉及任何DOM处理，在处理完更新后，需要渲染模块将更新渲染至DOM，这也是React应用中虚拟DOM（Virtual DOM）的概念，即所有的更新计算都基于虚拟DOM，计算完后才将优化后的更新渲染至真实DOM。Fiber使用<code>requestIdleCallback</code>API更高效的执行渲染更新的任务，实现任务的切分。</p>
<h3><span id="i-9">源码简单分析</span></h3>
<p>本小节针对React渲染模块及调和算法模块代码层关系做简要探讨，不感兴趣可以跳过此劫（节）。</p>
<h4><span id="react-dom">react-dom渲染模块</span></h4>
<p>在项目中，如果要将应用渲染至页面，通常会有如下代码：</p>
<pre><code class="react hljs coffeescript"><span class="hljs-keyword">import</span> ReactDOM <span class="hljs-keyword">from</span> <span class="hljs-string">'react-dom'</span>;
<span class="hljs-keyword">import</span> App form <span class="hljs-string">'./App'</span>; <span class="hljs-regexp">//</span> 应用根组件

ReactDOM.render(
  &lt;App&gt;,
  <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">'#App'</span>) <span class="hljs-regexp">//</span> 应用挂载容器DOM
);
</code></pre>
<p><code>react-dom</code>模块就是适用于浏览器端渲染React应用的渲染方案，<a href="https://github.com/facebook/react/blob/master/packages/react-dom/src/client/ReactDOM.js">ReactDOM模块源码</a>结构如：</p>
<pre><code class="react hljs php"><span class="hljs-keyword">const</span> ReactDOM = {
  render(
    element: React$Element&lt;any&gt;, <span class="hljs-comment">// React元素，通常是项目根组件</span>
    container: DOMContainer, <span class="hljs-comment">// React应用挂载的DOM容器</span>
    callback: ?<span class="hljs-function"><span class="hljs-keyword">Function</span>,  // 回调函数
  ) </span>{
    <span class="hljs-keyword">return</span> renderSubtreeIntoContainer(
      <span class="hljs-keyword">null</span>,
      element,
      container,
      <span class="hljs-keyword">false</span>,
      callback,
    );
  }
};
</code></pre>
<p>常用的渲染组件至DOM的<code>render</code>方法如上，调用<code>renderSubtreeIntoContainer</code>方法，渲染组件的子组件树：</p>
<pre><code class="react hljs javascript"><span class="hljs-comment">// 渲染组件的子组件树至父容器</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">renderSubtreeIntoContainer</span>(<span class="hljs-params">
  parentComponent: ?React$Component&lt;any, any&gt;,
  children: ReactNodeList,
  container: DOMContainer,
  forceHydrate: boolean,
  callback: ?Function,
</span>) </span>{
  <span class="hljs-keyword">let</span> root = container._reactRootContainer;
  <span class="hljs-keyword">if</span> (!root) {
    <span class="hljs-comment">// 初次渲染时初始化</span>
    <span class="hljs-comment">// 创建react根容器</span>
    <span class="hljs-keyword">const</span> newRoot = DOMRenderer.createContainer(container, shouldHydrate);
    <span class="hljs-comment">// 缓存react根容器至DOM容器的reactRootContainer属性</span>
    root = container._reactRootContainer = newRoot;
    <span class="hljs-comment">// 初始化容器相关</span>
    <span class="hljs-comment">// Initial mount should not be batched.</span>
    DOMRenderer.unbatchedUpdates(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
      DOMRenderer.updateContainer(children, newRoot, parentComponent, callback);
    });
  } <span class="hljs-keyword">else</span> {
    <span class="hljs-comment">// 如果不是初次渲染则直接更新容器</span>
    DOMRenderer.updateContainer(children, root, parentComponent, callback);
  }
  <span class="hljs-comment">// 返回根容器fiber树的根fiber实例</span>
  <span class="hljs-keyword">return</span> DOMRenderer.getPublicRootInstance(root);      
}
</code></pre>
<h5><span id="DOM">DOM渲染器对象</span></h5>
<p><code>DOMRenderer</code>是调用调和算法返回的DOM渲染器对象，在此处会传入渲染模块的渲染UI操作API，如：</p>
<pre><code class="react hljs javascript"><span class="hljs-comment">// 调用调和算法方法</span>
<span class="hljs-keyword">const</span> DOMRenderer = ReactFiberReconciler(
  <span class="hljs-comment">// 传递至调和算法中的渲染UI（react-dom模块即DOM）</span>
  <span class="hljs-comment">// 实际操作API</span>
  {
  getPublicInstance(instance) {
    <span class="hljs-keyword">return</span> instance;
  },
  createInstance(
    type: string,
    <span class="hljs-attr">props</span>: Props,
    <span class="hljs-attr">rootContainerInstance</span>: Container,
    <span class="hljs-attr">hostContext</span>: HostContext,
    <span class="hljs-attr">internalInstanceHandle</span>: <span class="hljs-built_in">Object</span>,
  ) {
    <span class="hljs-comment">// 创建DOM元素</span>
    <span class="hljs-keyword">const</span> domElement = createElement(
      type,
      props,
      rootContainerInstance,
      parentNamespace,
    );
    precacheFiberNode(internalInstanceHandle, domElement);
    updateFiberProps(domElement, props);
    <span class="hljs-keyword">return</span> domElement;      
  },
  <span class="hljs-attr">now</span>: ReactDOMFrameScheduling.now,
  <span class="hljs-attr">mutation</span>: {
    <span class="hljs-comment">// 提交渲染</span>
    commitMount(
      domElement: Instance,
      <span class="hljs-attr">type</span>: string,
      <span class="hljs-attr">newProps</span>: Props,
      <span class="hljs-attr">internalInstanceHandle</span>: <span class="hljs-built_in">Object</span>,
    ) {
      ((domElement: any):
        | HTMLButtonElement
        | HTMLInputElement
        | HTMLSelectElement
        | HTMLTextAreaElement).focus();
    },
    <span class="hljs-comment">// 提交更新</span>
    commitUpdate(
      domElement: Instance,
      <span class="hljs-attr">updatePayload</span>: <span class="hljs-built_in">Array</span>&lt;mixed&gt;,
      <span class="hljs-attr">type</span>: string,
      <span class="hljs-attr">oldProps</span>: Props,
      <span class="hljs-attr">newProps</span>: Props,
      <span class="hljs-attr">internalInstanceHandle</span>: <span class="hljs-built_in">Object</span>,
    ) {
      <span class="hljs-comment">// 更新属性</span>
      updateFiberProps(domElement, newProps);
      <span class="hljs-comment">// 对DOM节点进行Diff算法分析</span>
      updateProperties(domElement, updatePayload, type, oldProps, newProps);
    },
    <span class="hljs-comment">// 清空文本内容</span>
    resetTextContent(domElement: Instance): <span class="hljs-keyword">void</span> {
      domElement.textContent = <span class="hljs-string">''</span>;
    },
    <span class="hljs-comment">// 添加为子级</span>
    appendChild(
      parentInstance: Instance,
      <span class="hljs-attr">child</span>: Instance | TextInstance,
    ): <span class="hljs-keyword">void</span> {
      parentInstance.appendChild(child);
    }
    ...
  }
});
</code></pre>
<p><a href="https://github.com/facebook/react/blob/master/packages/shared/ReactDOMFrameScheduling.js">ReactDOMFrameScheduling.now源码见Github</a>。</p>
<p>在任务完成时将执行<code>createInstance</code>方法，然后调用<code>createElement</code>创建DOM元素并添加至文档。</p>
<h4><span id="i-10">调和算法入口</span></h4>
<p><a href="https://github.com/facebook/react/blob/master/packages/react-reconciler/src/ReactFiberReconciler.js">调和算法</a>入口：</p>
<pre><code class="react hljs javascript"><span class="hljs-keyword">import</span> ReactFiberScheduler <span class="hljs-keyword">from</span> <span class="hljs-string">'./ReactFiberScheduler'</span>;
<span class="hljs-keyword">import</span> {insertUpdateIntoFiber} <span class="hljs-keyword">from</span> <span class="hljs-string">'./ReactFiberUpdateQueue'</span>;

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Reconciler</span>(<span class="hljs-params">
  <span class="hljs-regexp">//</span> all parameters as config object
  <span class="hljs-regexp">//</span> 下文用到的config参数即从此处传入
  getPublicInstance,
  createInstance,
  ...
</span>) </span>{
  <span class="hljs-comment">// 生成调度器API</span>
  <span class="hljs-keyword">var</span> {
    computeAsyncExpiration, computeExpirationForFiber, scheduleWork,
    batchedUpdates, unbatchedUpdates, flushSync, deferredUpdates,
  } = ReactFiberScheduler(config);

  <span class="hljs-keyword">return</span> {
    <span class="hljs-comment">// 创建容器</span>
    createContainer(containerInfo, <span class="hljs-attr">hydrate</span>: boolean) {
      <span class="hljs-comment">// 创建根fiber实例</span>
      <span class="hljs-keyword">return</span> createFiberRoot(containerInfo, hydrate);
    },
    <span class="hljs-comment">// 更新容器内容</span>
    updateContainer(
      element: ReactNodeList,
      <span class="hljs-attr">container</span>: OpaqueRoot,
      <span class="hljs-attr">parentComponent</span>: ?React$Component&lt;any, any&gt;,
      <span class="hljs-attr">callback</span>: ?<span class="hljs-built_in">Function</span>,
    ): <span class="hljs-keyword">void</span> {
      <span class="hljs-keyword">const</span> current = container.current;
      ...
      <span class="hljs-comment">// 更新</span>
      scheduleTopLevelUpdate(current, element, callback);
    },
    ...
    <span class="hljs-comment">// 获取容器fiber树的根fiber实例</span>
    getPublicRootInstance (container) {
      <span class="hljs-comment">// 获取fiber实例</span>
      <span class="hljs-keyword">const</span> containerFiber = container.current;
      <span class="hljs-keyword">if</span> (!containerFiber.child) {
        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
      }
      <span class="hljs-keyword">switch</span> (containerFiber.child.tag) {
        <span class="hljs-keyword">case</span> HostComponent:
          <span class="hljs-keyword">return</span> getPublicInstance(containerFiber.child.stateNode);
        <span class="hljs-keyword">default</span>:
          <span class="hljs-keyword">return</span> containerFiber.child.stateNode;
      }
    },
    unbatchedUpdates
  }
}
</code></pre>
<p>在<code>react-dom</code>渲染模块调用<code>createContainer</code>创建容器和根fiber实例，FiberRoot对象，调用<code>updateContainer</code>方法更新容器内容。</p>
<h5><span id="i-11">开始更新</span></h5>
<pre><code class="react hljs javascript"><span class="hljs-comment">// 更新</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">scheduleTopLevelUpdate</span>(<span class="hljs-params">
    current: Fiber,
    element: ReactNodeList,
    callback: ?Function,
  </span>) </span>{
  callback = callback === <span class="hljs-literal">undefined</span> ? <span class="hljs-literal">null</span> : callback;
  <span class="hljs-keyword">const</span> update = {
    expirationTime,
    <span class="hljs-attr">partialState</span>: {element},
    callback,
    <span class="hljs-attr">isReplace</span>: <span class="hljs-literal">false</span>,
    <span class="hljs-attr">isForced</span>: <span class="hljs-literal">false</span>,
    <span class="hljs-attr">nextCallback</span>: <span class="hljs-literal">null</span>,
    <span class="hljs-attr">next</span>: <span class="hljs-literal">null</span>,
  };
  <span class="hljs-comment">// 更新fiber实例</span>
  insertUpdateIntoFiber(current, update);
  <span class="hljs-comment">// 执行任务</span>
  scheduleWork(current, expirationTime);
}
</code></pre>
<h5><span id="i-12">处理更新</span></h5>
<p>调用<code>scheduleWork</code>方法处理更新任务，实现见上文，<a href="https://github.com/facebook/react/blob/master/packages/react-reconciler/src/ReactFiberScheduler.js">源码</a>。</p>
<h5><span id="i-13">提交更新</span></h5>
<p>处理完更新后需要确认提交更新至渲染模块，然后渲染模块才能将更新渲染至DOM。</p>
<pre><code class="react hljs javascript"><span class="hljs-keyword">import</span> ReactFiberCommitWork <span class="hljs-keyword">from</span> <span class="hljs-string">'./ReactFiberCommitWork'</span>;

<span class="hljs-keyword">const</span> {
    commitResetTextContent,
    commitPlacement,
    commitDeletion,
    commitWork,
    commitLifeCycles,
    commitAttachRef,
    commitDetachRef,
  } = ReactFiberCommitWork(config, captureError);

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">commitRoot</span>(<span class="hljs-params">finishedWork</span>) </span>{
  ...
  commitAllHostEffects();
}
<span class="hljs-comment">// 循环执行提交更新</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">commitAllHostEffects</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">while</span> (nextEffect !== <span class="hljs-literal">null</span>) {
    <span class="hljs-keyword">let</span> primaryEffectTag =
        effectTag &amp; ~(Callback | Err | ContentReset | Ref | PerformedWork);
      <span class="hljs-keyword">switch</span> (primaryEffectTag) {
        <span class="hljs-keyword">case</span> Placement: {
          commitPlacement(nextEffect);
          nextEffect.effectTag &amp;= ~Placement;
          <span class="hljs-keyword">break</span>;
        }
        <span class="hljs-keyword">case</span> PlacementAndUpdate: {
          <span class="hljs-comment">// Placement</span>
          commitPlacement(nextEffect);
          nextEffect.effectTag &amp;= ~Placement;
          <span class="hljs-comment">// Update</span>
          <span class="hljs-keyword">const</span> current = nextEffect.alternate;
          commitWork(current, nextEffect);
          <span class="hljs-keyword">break</span>;
        }
        <span class="hljs-keyword">case</span> Update: {
          <span class="hljs-keyword">const</span> current = nextEffect.alternate;
          commitWork(current, nextEffect);
          <span class="hljs-keyword">break</span>;
        }
        <span class="hljs-keyword">case</span> Deletion: {
          isUnmounting = <span class="hljs-literal">true</span>;
          commitDeletion(nextEffect);
          isUnmounting = <span class="hljs-literal">false</span>;
          <span class="hljs-keyword">break</span>;
        }
      }
      nextEffect = nextEffect.nextEffect;
  }
}
<span class="hljs-comment">// Flush sync work.</span>
<span class="hljs-keyword">let</span> finishedWork = root.finishedWork;
<span class="hljs-keyword">if</span> (finishedWork !== <span class="hljs-literal">null</span>) {
  <span class="hljs-comment">// This root is already complete. We can commit it.</span>
  root.finishedWork = <span class="hljs-literal">null</span>;
  root.remainingExpirationTime = commitRoot(finishedWork);
}
</code></pre>
<p><a href="https://github.com/facebook/react/blob/master/packages/react-reconciler/src/ReactFiberCommitWork.js">提交更新</a>是最后确认更新组件的阶段，主要逻辑如下：</p>
<pre><code class="react hljs php">export <span class="hljs-keyword">default</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(mutation, ...)</span> </span>{
  <span class="hljs-keyword">const</span> {
    commitMount,
    commitUpdate,
    resetTextContent,
    commitTextUpdate,
    appendChild,
    appendChildToContainer,
    insertBefore,
    insertInContainerBefore,
    removeChild,
    removeChildFromContainer,
  } = mutation; 

  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">commitWork</span><span class="hljs-params">(current: Fiber | null, finishedWork: Fiber)</span>: <span class="hljs-title">void</span> </span>{
    <span class="hljs-keyword">switch</span> (finishedWork.tag) {
      <span class="hljs-keyword">case</span> ClassComponent: {
        <span class="hljs-keyword">return</span>;
      }
      <span class="hljs-keyword">case</span> HostComponent: {
        <span class="hljs-keyword">const</span> instance: I = finishedWork.stateNode;
        <span class="hljs-keyword">if</span> (instance != <span class="hljs-keyword">null</span>) {
          <span class="hljs-comment">// Commit the work prepared earlier.</span>
          <span class="hljs-keyword">const</span> newProps = finishedWork.memoizedProps;
          <span class="hljs-comment">// For hydration we reuse the update path but we treat the oldProps</span>
          <span class="hljs-comment">// as the newProps. The updatePayload will contain the real change in</span>
          <span class="hljs-comment">// this case.</span>
          <span class="hljs-keyword">const</span> oldProps = current !== <span class="hljs-keyword">null</span> ? current.memoizedProps : newProps;
          <span class="hljs-keyword">const</span> type = finishedWork.type;
          <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> Type the updateQueue to be specific to host components.</span>
          <span class="hljs-keyword">const</span> updatePayload = finishedWork.updateQueue:;
          finishedWork.updateQueue = <span class="hljs-keyword">null</span>;
          <span class="hljs-keyword">if</span> (updatePayload !== <span class="hljs-keyword">null</span>) {
            commitUpdate(
              instance,
              updatePayload,
              type,
              oldProps,
              newProps,
              finishedWork,
            );
          }
        }
        <span class="hljs-keyword">return</span>;
      }
      <span class="hljs-keyword">case</span> HostText: {   
        <span class="hljs-keyword">const</span> textInstance = finishedWork.stateNode;
        <span class="hljs-keyword">const</span> newText = finishedWork.memoizedProps;
        <span class="hljs-comment">// For hydration we reuse the update path but we treat the oldProps</span>
        <span class="hljs-comment">// as the newProps. The updatePayload will contain the real change in</span>
        <span class="hljs-comment">// this case.</span>
        <span class="hljs-keyword">const</span> oldText: string =
          current !== <span class="hljs-keyword">null</span> ? current.memoizedProps : newText;
        commitTextUpdate(textInstance, oldText, newText);
        <span class="hljs-keyword">return</span>;
      }
      <span class="hljs-keyword">case</span> HostRoot: {
        <span class="hljs-keyword">return</span>;
      }
      <span class="hljs-keyword">default</span>: {
      }
    }
  }
}
</code></pre>
<h2><span id="i-14">参考</span></h2>
<ol>
<li><a href="https://github.com/facebook/react/">React Source Code</a></li>
<li><a href="https://github.com/acdlite/react-fiber-architecture">React Fiber Architecture</a></li>
<li><a href="http://makersden.io/blog/look-inside-fiber/">A look inside React Fiber</a></li>
<li><a href="https://edgecoders.com/react-16-features-and-fiber-explanation-e779544bb1b7">An overview of React 16 features and Fiber</a></li>
<li><a href="https://www.w3.org/TR/requestidlecallback/">requestIdleCallback</a></li>
</ol>
<div style="
    margin: 20px -20px;
    background-color: #f3f2f2;
    padding: 10px 20px;
    box-shadow: 0px 1px 1px 1px #e7e2e2;"><p></p>
<p><strong>原创文章，转载请注明：</strong> 转载自 <a href="http://blog.codingplayboy.com/">熊建刚的博客</a></p>
<p><strong>本文链接地址:  </strong> <a href="http://blog.codingplayboy.com/2017/12/02/react_fiber/">React Fiber初探</a></p>
</div>
<div style="clear:both; margin-top:5px; margin-bottom:5px;"></div><div style="float:left"><!-- JiaThis Button BEGIN -->
<div class="jiathis_style">
	<span class="jiathis_txt">分享到：</span>
	<a class="jiathis_button_qzone">QQ空间</a>
	<a class="jiathis_button_tsina">新浪微博</a>
	<a class="jiathis_button_weixin">微信</a>
	<a class="jiathis_button_cqq">QQ好友</a>
	<a class="jiathis_button_ydnote">有道云笔记</a>
	<a class="jiathis_button_email">邮件</a>
	<a href="http://www.jiathis.com/share" class="jiathis jiathis_txt jiathis_separator jtico jtico_jiathis" target="_blank">更多</a>
	<a class="jiathis_counter_style"></a>
</div>
<script type="text/javascript" src="./React Fiber初探 – 熊建刚的博客_files/jia.js" charset="utf-8"></script>
<!-- JiaThis Button END -->
</div><div style="clear:both; margin-top:5px; margin-bottom:5px;"></div>	</div><!-- .entry-content -->
		
	<footer class="entry-footer">
		<span class="cat-links"><span class="icon-folder"></span> Category: <a href="http://blog.codingplayboy.com/category/spa/reactjs/" rel="category tag">React</a></span><span class="tags-links"><span class="icon-tag"></span> Tag: <a href="http://blog.codingplayboy.com/tag/fiber/" rel="tag">Fiber</a>, <a href="http://blog.codingplayboy.com/tag/react/" rel="tag">React</a>, <a href="http://blog.codingplayboy.com/tag/reconciliation/" rel="tag">Reconciliation</a></span><span class="comments-link"><a href="http://blog.codingplayboy.com/2017/12/02/react_fiber/#comments">1 Comment</a></span>	</footer><!-- .entry-footer -->
</article><!-- #post-## -->


<div class="author-info clear">
	<div class="author-avatar">
		<img alt="" src="./React Fiber初探 – 熊建刚的博客_files/7039825bb92282182b4cad9916216917.png" srcset="http://1.gravatar.com/avatar/7039825bb92282182b4cad9916216917?s=160&amp;d=mm&amp;r=g 2x" class="avatar avatar-80 photo" height="80" width="80">	</div><!-- .author-avatar -->

	<div class="author-description">
		<h3 class="author-title">熊 建刚</h3>
		<p class="author-bio">
			热爱前端，但不局限于前端，喜欢尝试各种新技术，爱好读书。			<a class="author-link" href="http://blog.codingplayboy.com/author/jhss_xjg/" rel="author">
				View all posts by 熊 建刚			</a>
		</p><!-- .author-bio -->
	</div><!-- .author-description -->
	
	<div class="author-social">
			</div><!-- .author-social -->
</div><!-- .author-info -->

	<nav class="navigation post-navigation" role="navigation">
		<h2 class="screen-reader-text">文章导航</h2>
		<div class="nav-links"><div class="nav-previous"><a href="http://blog.codingplayboy.com/2017/11/30/linux_php-fpm_memory_problem/" rel="prev">Previous Post<span>Linux下php-fpm进程过多导致内存耗尽问题解决</span></a></div><div class="nav-next"><a href="http://blog.codingplayboy.com/2017/12/12/nginx-error-500/" rel="next">Next Post<span>解决Nginx服务返回500状态码问题</span></a></div></div>
	</nav>				
				
<div id="comments" class="comments-area">

	
			<h2 class="comments-title">
			One thought on “<span>React Fiber初探</span>”		</h2>

		
		<ol class="comment-list">
					<li id="comment-84117" class="pingback even thread-even depth-1">
			<div class="comment-body">
				Pingback： <a href="https://codertw.com/%e5%89%8d%e7%ab%af%e9%96%8b%e7%99%bc/2713/" rel="external nofollow" class="url">React Fiber初探 | 程式前沿</a> 			</div>
</li><!-- #comment-## -->
		</ol><!-- .comment-list -->

		
	
	
		<div id="respond" class="comment-respond">
		<h3 id="reply-title" class="comment-reply-title">发表评论 <small><a rel="nofollow" id="cancel-comment-reply-link" href="http://blog.codingplayboy.com/2017/12/02/react_fiber/#respond" style="display:none;">取消回复</a></small></h3>			<form action="http://blog.codingplayboy.com/wp-comments-post.php" method="post" id="commentform" class="comment-form" novalidate="">
				<p class="comment-notes"><span id="email-notes">电子邮件地址不会被公开。</span> 必填项已用<span class="required">*</span>标注</p><p class="comment-form-comment"><label for="comment">评论</label> <textarea id="comment" name="w" cols="45" rows="8" maxlength="65525" aria-required="true" required="required"></textarea><textarea name="comment" cols="100%" rows="4" style="display:none"></textarea></p><p class="comment-form-author"><label for="author">姓名 <span class="required">*</span></label> <input id="author" name="author" type="text" value="" size="30" maxlength="245" aria-required="true" required="required"></p>
<p class="comment-form-email"><label for="email">电子邮件 <span class="required">*</span></label> <input id="email" name="email" type="email" value="" size="30" maxlength="100" aria-describedby="email-notes" aria-required="true" required="required"></p>
<p class="comment-form-url"><label for="url">站点</label> <input id="url" name="url" type="url" value="" size="30" maxlength="200"></p>
<p class="form-submit"><input name="submit" type="submit" id="submit" class="submit" value="发表评论"> <input type="hidden" name="comment_post_ID" value="888" id="comment_post_ID">
<input type="hidden" name="comment_parent" id="comment_parent" value="0">
</p><p style="display: none;"><input type="hidden" id="akismet_comment_nonce" name="akismet_comment_nonce" value="7b09a8c283"></p><p style="display: none;"></p>			<input type="hidden" id="ak_js" name="ak_js" value="1526988222839"></form>
			</div><!-- #respond -->
	
</div><!-- #comments -->
						
		</main><!-- #main -->
	</div><!-- #primary -->



<div id="secondary" class="sidebar widget-area  widget-grey" role="complementary">

		
		
		<aside id="calendar-6" class="widget widget_calendar"><div id="calendar_wrap" class="calendar_wrap"><table id="wp-calendar">
	<caption>2017年十二月</caption>
	<thead>
	<tr>
		<th scope="col" title="星期一">一</th>
		<th scope="col" title="星期二">二</th>
		<th scope="col" title="星期三">三</th>
		<th scope="col" title="星期四">四</th>
		<th scope="col" title="星期五">五</th>
		<th scope="col" title="星期六">六</th>
		<th scope="col" title="星期日">日</th>
	</tr>
	</thead>

	<tfoot>
	<tr>
		<td colspan="3" id="prev"><a href="http://blog.codingplayboy.com/2017/11/">« 11月</a></td>
		<td class="pad">&nbsp;</td>
		<td colspan="3" id="next"><a href="http://blog.codingplayboy.com/2018/01/">1月 »</a></td>
	</tr>
	</tfoot>

	<tbody>
	<tr>
		<td colspan="4" class="pad">&nbsp;</td><td>1</td><td><a href="http://blog.codingplayboy.com/2017/12/02/" aria-label="于2017年12月2日上发布的文章">2</a></td><td>3</td>
	</tr>
	<tr>
		<td>4</td><td>5</td><td>6</td><td>7</td><td>8</td><td>9</td><td>10</td>
	</tr>
	<tr>
		<td>11</td><td><a href="http://blog.codingplayboy.com/2017/12/12/" aria-label="于2017年12月12日上发布的文章">12</a></td><td><a href="http://blog.codingplayboy.com/2017/12/13/" aria-label="于2017年12月13日上发布的文章">13</a></td><td>14</td><td>15</td><td>16</td><td>17</td>
	</tr>
	<tr>
		<td><a href="http://blog.codingplayboy.com/2017/12/18/" aria-label="于2017年12月18日上发布的文章">18</a></td><td>19</td><td>20</td><td>21</td><td>22</td><td>23</td><td>24</td>
	</tr>
	<tr>
		<td>25</td><td><a href="http://blog.codingplayboy.com/2017/12/26/" aria-label="于2017年12月26日上发布的文章">26</a></td><td>27</td><td>28</td><td>29</td><td><a href="http://blog.codingplayboy.com/2017/12/30/" aria-label="于2017年12月30日上发布的文章">30</a></td><td><a href="http://blog.codingplayboy.com/2017/12/31/" aria-label="于2017年12月31日上发布的文章">31</a></td>
	</tr>
	</tbody>
	</table></div></aside>		<aside id="recent-posts-6" class="widget widget_recent_entries">		<h3 class="widget-title"><span>近期文章</span></h3>		<ul>
											<li>
					<a href="http://blog.codingplayboy.com/2018/05/19/react_native_babel_error/">React Native babel编译异常问题解决</a>
									</li>
											<li>
					<a href="http://blog.codingplayboy.com/2018/04/15/react_native_dev/">React Native项目真机调试(一)</a>
									</li>
											<li>
					<a href="http://blog.codingplayboy.com/2018/02/11/mobx-vs-redux/">你需要Mobx还是Redux？</a>
									</li>
											<li>
					<a href="http://blog.codingplayboy.com/2018/01/06/responsive-web-design/">浅谈响应式Web设计与实现思路</a>
									</li>
											<li>
					<a href="http://blog.codingplayboy.com/2017/12/31/2017-report/">2017年终总结与来年展望</a>
									</li>
					</ul>
		</aside><aside id="categories-3" class="widget widget_categories"><h3 class="widget-title"><span>分类目录</span></h3>		<ul>
	<li class="cat-item cat-item-3"><a href="http://blog.codingplayboy.com/category/css/">CSS</a> (15)
<ul class="children">
	<li class="cat-item cat-item-4"><a href="http://blog.codingplayboy.com/category/css/css3/">CSS3</a> (6)
</li>
</ul>
</li>
	<li class="cat-item cat-item-127"><a href="http://blog.codingplayboy.com/category/gitsvn/">Git/SVN</a> (9)
</li>
	<li class="cat-item cat-item-5"><a href="http://blog.codingplayboy.com/category/html/">HTML</a> (15)
<ul class="children">
	<li class="cat-item cat-item-6"><a href="http://blog.codingplayboy.com/category/html/html5/">HTML5</a> (9)
</li>
</ul>
</li>
	<li class="cat-item cat-item-7"><a href="http://blog.codingplayboy.com/category/js/">JavaScript</a> (39)
<ul class="children">
	<li class="cat-item cat-item-143"><a href="http://blog.codingplayboy.com/category/js/ecmascript-2015/">es6</a> (1)
</li>
	<li class="cat-item cat-item-8"><a href="http://blog.codingplayboy.com/category/js/jquery/">jQuery</a> (1)
</li>
</ul>
</li>
	<li class="cat-item cat-item-59"><a href="http://blog.codingplayboy.com/category/linux/">Linux</a> (4)
</li>
	<li class="cat-item cat-item-9"><a href="http://blog.codingplayboy.com/category/node/">NodeJs</a> (2)
</li>
	<li class="cat-item cat-item-10"><a href="http://blog.codingplayboy.com/category/web/">Web</a> (11)
</li>
	<li class="cat-item cat-item-164"><a href="http://blog.codingplayboy.com/category/pack/">前端自动化</a> (4)
<ul class="children">
	<li class="cat-item cat-item-165"><a href="http://blog.codingplayboy.com/category/pack/webpack/">Webpack</a> (4)
</li>
</ul>
</li>
	<li class="cat-item cat-item-141"><a href="http://blog.codingplayboy.com/category/spa/" title="单页应用框架">单页应用</a> (26)
<ul class="children">
	<li class="cat-item cat-item-2"><a href="http://blog.codingplayboy.com/category/spa/backbone/">Backbone</a> (5)
</li>
	<li class="cat-item cat-item-72"><a href="http://blog.codingplayboy.com/category/spa/reactjs/">React</a> (17)
</li>
	<li class="cat-item cat-item-159"><a href="http://blog.codingplayboy.com/category/spa/vue/">Vue</a> (2)
</li>
</ul>
</li>
	<li class="cat-item cat-item-67"><a href="http://blog.codingplayboy.com/category/mobile/">移动开发</a> (8)
<ul class="children">
	<li class="cat-item cat-item-179"><a href="http://blog.codingplayboy.com/category/mobile/react-native/">React Native</a> (4)
</li>
</ul>
</li>
	<li class="cat-item cat-item-11"><a href="http://blog.codingplayboy.com/category/sundry/">随笔</a> (3)
</li>
		</ul>
</aside><aside id="tag_cloud-5" class="widget widget_tag_cloud"><h3 class="widget-title"><span>标签</span></h3><div class="tagcloud"><a href="http://blog.codingplayboy.com/tag/algorithm/" class="tag-cloud-link tag-link-12 tag-link-position-1" style="font-size: 10.117647058824pt;" aria-label="algorithm (2个项目)">algorithm</a>
<a href="http://blog.codingplayboy.com/tag/amdcmd/" class="tag-cloud-link tag-link-13 tag-link-position-2" style="font-size: 8pt;" aria-label="AMD/CMD (1个项目)">AMD/CMD</a>
<a href="http://blog.codingplayboy.com/tag/apply/" class="tag-cloud-link tag-link-14 tag-link-position-3" style="font-size: 8pt;" aria-label="apply (1个项目)">apply</a>
<a href="http://blog.codingplayboy.com/tag/babel/" class="tag-cloud-link tag-link-192 tag-link-position-4" style="font-size: 10.117647058824pt;" aria-label="Babel (2个项目)">Babel</a>
<a href="http://blog.codingplayboy.com/tag/backbone/" class="tag-cloud-link tag-link-15 tag-link-position-5" style="font-size: 13.647058823529pt;" aria-label="Backbone (5个项目)">Backbone</a>
<a href="http://blog.codingplayboy.com/tag/body/" class="tag-cloud-link tag-link-16 tag-link-position-6" style="font-size: 8pt;" aria-label="body (1个项目)">body</a>
<a href="http://blog.codingplayboy.com/tag/box-shadow/" class="tag-cloud-link tag-link-17 tag-link-position-7" style="font-size: 8pt;" aria-label="box-shadow (1个项目)">box-shadow</a>
<a href="http://blog.codingplayboy.com/tag/call/" class="tag-cloud-link tag-link-18 tag-link-position-8" style="font-size: 8pt;" aria-label="call (1个项目)">call</a>
<a href="http://blog.codingplayboy.com/tag/collection/" class="tag-cloud-link tag-link-19 tag-link-position-9" style="font-size: 8pt;" aria-label="Collection (1个项目)">Collection</a>
<a href="http://blog.codingplayboy.com/tag/compile/" class="tag-cloud-link tag-link-20 tag-link-position-10" style="font-size: 8pt;" aria-label="compile (1个项目)">compile</a>
<a href="http://blog.codingplayboy.com/tag/cookie/" class="tag-cloud-link tag-link-21 tag-link-position-11" style="font-size: 8pt;" aria-label="cookie (1个项目)">cookie</a>
<a href="http://blog.codingplayboy.com/tag/css/" class="tag-cloud-link tag-link-22 tag-link-position-12" style="font-size: 17.176470588235pt;" aria-label="CSS (11个项目)">CSS</a>
<a href="http://blog.codingplayboy.com/tag/css3/" class="tag-cloud-link tag-link-23 tag-link-position-13" style="font-size: 14.470588235294pt;" aria-label="CSS3 (6个项目)">CSS3</a>
<a href="http://blog.codingplayboy.com/tag/documentelement/" class="tag-cloud-link tag-link-24 tag-link-position-14" style="font-size: 8pt;" aria-label="documentElement (1个项目)">documentElement</a>
<a href="http://blog.codingplayboy.com/tag/dom/" class="tag-cloud-link tag-link-25 tag-link-position-15" style="font-size: 11.529411764706pt;" aria-label="DOM (3个项目)">DOM</a>
<a href="http://blog.codingplayboy.com/tag/float/" class="tag-cloud-link tag-link-26 tag-link-position-16" style="font-size: 10.117647058824pt;" aria-label="float (2个项目)">float</a>
<a href="http://blog.codingplayboy.com/tag/git/" class="tag-cloud-link tag-link-128 tag-link-position-17" style="font-size: 16.235294117647pt;" aria-label="Git (9个项目)">Git</a>
<a href="http://blog.codingplayboy.com/tag/gulp/" class="tag-cloud-link tag-link-27 tag-link-position-18" style="font-size: 8pt;" aria-label="gulp (1个项目)">gulp</a>
<a href="http://blog.codingplayboy.com/tag/html/" class="tag-cloud-link tag-link-28 tag-link-position-19" style="font-size: 15.647058823529pt;" aria-label="HTML (8个项目)">HTML</a>
<a href="http://blog.codingplayboy.com/tag/html5/" class="tag-cloud-link tag-link-29 tag-link-position-20" style="font-size: 13.647058823529pt;" aria-label="HTML5 (5个项目)">HTML5</a>
<a href="http://blog.codingplayboy.com/tag/immutable/" class="tag-cloud-link tag-link-174 tag-link-position-21" style="font-size: 10.117647058824pt;" aria-label="immutable (2个项目)">immutable</a>
<a href="http://blog.codingplayboy.com/tag/javascript/" class="tag-cloud-link tag-link-30 tag-link-position-22" style="font-size: 22pt;" aria-label="JavaScript (30个项目)">JavaScript</a>
<a href="http://blog.codingplayboy.com/tag/jquery/" class="tag-cloud-link tag-link-31 tag-link-position-23" style="font-size: 8pt;" aria-label="jQuery (1个项目)">jQuery</a>
<a href="http://blog.codingplayboy.com/tag/linux/" class="tag-cloud-link tag-link-155 tag-link-position-24" style="font-size: 11.529411764706pt;" aria-label="Linux (3个项目)">Linux</a>
<a href="http://blog.codingplayboy.com/tag/load/" class="tag-cloud-link tag-link-32 tag-link-position-25" style="font-size: 8pt;" aria-label="Load (1个项目)">Load</a>
<a href="http://blog.codingplayboy.com/tag/mobile/" class="tag-cloud-link tag-link-68 tag-link-position-26" style="font-size: 11.529411764706pt;" aria-label="mobile (3个项目)">mobile</a>
<a href="http://blog.codingplayboy.com/tag/nginx/" class="tag-cloud-link tag-link-156 tag-link-position-27" style="font-size: 10.117647058824pt;" aria-label="nginx (2个项目)">nginx</a>
<a href="http://blog.codingplayboy.com/tag/promise/" class="tag-cloud-link tag-link-39 tag-link-position-28" style="font-size: 10.117647058824pt;" aria-label="Promise (2个项目)">Promise</a>
<a href="http://blog.codingplayboy.com/tag/react/" class="tag-cloud-link tag-link-73 tag-link-position-29" style="font-size: 18.352941176471pt;" aria-label="React (14个项目)">React</a>
<a href="http://blog.codingplayboy.com/tag/react-router/" class="tag-cloud-link tag-link-84 tag-link-position-30" style="font-size: 11.529411764706pt;" aria-label="react-router (3个项目)">react-router</a>
<a href="http://blog.codingplayboy.com/tag/react-native/" class="tag-cloud-link tag-link-172 tag-link-position-31" style="font-size: 12.705882352941pt;" aria-label="React Native (4个项目)">React Native</a>
<a href="http://blog.codingplayboy.com/tag/redux/" class="tag-cloud-link tag-link-175 tag-link-position-32" style="font-size: 13.647058823529pt;" aria-label="redux (5个项目)">redux</a>
<a href="http://blog.codingplayboy.com/tag/redux-immutable/" class="tag-cloud-link tag-link-176 tag-link-position-33" style="font-size: 11.529411764706pt;" aria-label="redux-immutable (3个项目)">redux-immutable</a>
<a href="http://blog.codingplayboy.com/tag/spa/" class="tag-cloud-link tag-link-167 tag-link-position-34" style="font-size: 11.529411764706pt;" aria-label="SPA (3个项目)">SPA</a>
<a href="http://blog.codingplayboy.com/tag/version-controll-system/" class="tag-cloud-link tag-link-130 tag-link-position-35" style="font-size: 16.235294117647pt;" aria-label="version controll system (9个项目)">version controll system</a>
<a href="http://blog.codingplayboy.com/tag/viewport/" class="tag-cloud-link tag-link-71 tag-link-position-36" style="font-size: 10.117647058824pt;" aria-label="viewport (2个项目)">viewport</a>
<a href="http://blog.codingplayboy.com/tag/web/" class="tag-cloud-link tag-link-47 tag-link-position-37" style="font-size: 10.117647058824pt;" aria-label="web (2个项目)">web</a>
<a href="http://blog.codingplayboy.com/tag/webpack/" class="tag-cloud-link tag-link-166 tag-link-position-38" style="font-size: 12.705882352941pt;" aria-label="Webpack (4个项目)">Webpack</a>
<a href="http://blog.codingplayboy.com/tag/wordpress/" class="tag-cloud-link tag-link-48 tag-link-position-39" style="font-size: 10.117647058824pt;" aria-label="WordPress (2个项目)">WordPress</a>
<a href="http://blog.codingplayboy.com/tag/blogs/" class="tag-cloud-link tag-link-50 tag-link-position-40" style="font-size: 10.117647058824pt;" aria-label="博客 (2个项目)">博客</a>
<a href="http://blog.codingplayboy.com/tag/%e5%b9%b4%e7%bb%88%e6%80%bb%e7%bb%93/" class="tag-cloud-link tag-link-126 tag-link-position-41" style="font-size: 10.117647058824pt;" aria-label="年终总结 (2个项目)">年终总结</a>
<a href="http://blog.codingplayboy.com/tag/async/" class="tag-cloud-link tag-link-51 tag-link-position-42" style="font-size: 11.529411764706pt;" aria-label="异步 (3个项目)">异步</a>
<a href="http://blog.codingplayboy.com/tag/%e7%89%88%e6%9c%ac%e6%8e%a7%e5%88%b6/" class="tag-cloud-link tag-link-131 tag-link-position-43" style="font-size: 16.235294117647pt;" aria-label="版本控制 (9个项目)">版本控制</a>
<a href="http://blog.codingplayboy.com/tag/%e7%bb%84%e4%bb%b6/" class="tag-cloud-link tag-link-74 tag-link-position-44" style="font-size: 12.705882352941pt;" aria-label="组件 (4个项目)">组件</a>
<a href="http://blog.codingplayboy.com/tag/cross_origin/" class="tag-cloud-link tag-link-55 tag-link-position-45" style="font-size: 10.117647058824pt;" aria-label="跨域 (2个项目)">跨域</a></div>
</aside><aside id="archives-5" class="widget widget_archive"><h3 class="widget-title"><span>文章归档</span></h3>		<label class="screen-reader-text" for="archives-dropdown-5">文章归档</label>
		<select id="archives-dropdown-5" name="archive-dropdown" onchange="document.location.href=this.options[this.selectedIndex].value;">
			
			<option value="">选择月份</option>
				<option value="http://blog.codingplayboy.com/2018/05/"> 2018年五月 &nbsp;(1)</option>
	<option value="http://blog.codingplayboy.com/2018/04/"> 2018年四月 &nbsp;(1)</option>
	<option value="http://blog.codingplayboy.com/2018/02/"> 2018年二月 &nbsp;(1)</option>
	<option value="http://blog.codingplayboy.com/2018/01/"> 2018年一月 &nbsp;(1)</option>
	<option value="http://blog.codingplayboy.com/2017/12/"> 2017年十二月 &nbsp;(7)</option>
	<option value="http://blog.codingplayboy.com/2017/11/"> 2017年十一月 &nbsp;(2)</option>
	<option value="http://blog.codingplayboy.com/2017/10/"> 2017年十月 &nbsp;(1)</option>
	<option value="http://blog.codingplayboy.com/2017/09/"> 2017年九月 &nbsp;(4)</option>
	<option value="http://blog.codingplayboy.com/2017/06/"> 2017年六月 &nbsp;(2)</option>
	<option value="http://blog.codingplayboy.com/2017/05/"> 2017年五月 &nbsp;(6)</option>
	<option value="http://blog.codingplayboy.com/2017/04/"> 2017年四月 &nbsp;(4)</option>
	<option value="http://blog.codingplayboy.com/2017/03/"> 2017年三月 &nbsp;(4)</option>
	<option value="http://blog.codingplayboy.com/2017/01/"> 2017年一月 &nbsp;(4)</option>
	<option value="http://blog.codingplayboy.com/2016/12/"> 2016年十二月 &nbsp;(6)</option>
	<option value="http://blog.codingplayboy.com/2016/11/"> 2016年十一月 &nbsp;(7)</option>
	<option value="http://blog.codingplayboy.com/2016/10/"> 2016年十月 &nbsp;(6)</option>
	<option value="http://blog.codingplayboy.com/2016/09/"> 2016年九月 &nbsp;(1)</option>
	<option value="http://blog.codingplayboy.com/2016/08/"> 2016年八月 &nbsp;(2)</option>
	<option value="http://blog.codingplayboy.com/2016/07/"> 2016年七月 &nbsp;(4)</option>
	<option value="http://blog.codingplayboy.com/2016/06/"> 2016年六月 &nbsp;(3)</option>
	<option value="http://blog.codingplayboy.com/2016/05/"> 2016年五月 &nbsp;(2)</option>
	<option value="http://blog.codingplayboy.com/2016/04/"> 2016年四月 &nbsp;(2)</option>
	<option value="http://blog.codingplayboy.com/2016/03/"> 2016年三月 &nbsp;(5)</option>
	<option value="http://blog.codingplayboy.com/2016/02/"> 2016年二月 &nbsp;(2)</option>
	<option value="http://blog.codingplayboy.com/2016/01/"> 2016年一月 &nbsp;(19)</option>

		</select>
		</aside><aside id="wpstatistics_widget-6" class="widget widget_wpstatistics_widget"><h3 class="widget-title"><span>访问</span></h3><ul><li>今日访问: 5,827</li><li>累计访问: 7,976,218</li><li>累计访客: 482,347</li><li>总计文章: 97</li><li>最后发表日期: 2018-05-20</li></ul></aside><aside id="meta-5" class="widget widget_meta"><h3 class="widget-title"><span>功能</span></h3>			<ul>
						<li><a href="http://blog.codingplayboy.com/wp-login.php">登录</a></li>
			<li><a href="http://blog.codingplayboy.com/feed/">文章<abbr title="Really Simple Syndication">RSS</abbr></a></li>
			<li><a href="http://blog.codingplayboy.com/comments/feed/">评论<abbr title="Really Simple Syndication">RSS</abbr></a></li>
			<li><a href="https://cn.wordpress.org/" title="基于WordPress，一个优美、先进的个人信息发布平台。">WordPress.org</a></li>			</ul>
			</aside>	
		
</div><!-- #secondary .widget-area -->
		
		</div><!-- .container -->
	</div><!-- #content -->

	<footer id="colophon" class="site-footer" role="contentinfo">
		
		<div class="footer widget-area" role="complementary">
			<div class="container">
				<div class="row">
					<div class="col-4" id="footer-area-left">
											</div>	
					<div class="col-4" id="footer-area-center">
											</div>
					<div class="col-4" id="footer-area-right">
											</div>
				</div><!-- .row -->
			</div>
		</div>
		
		<div class="footer-copy">
			<div class="container">
				<div class="row">
					<div class="col-6">
						<div class="site-info">
							© 2018 熊建刚的博客							<span class="sep">/</span>
							<a href="http://mail.163.com/">Email: codingfun@163.com</a>
							<span class="sep"> / </span>
							<a href="http://github.com/codingplayboy">Github: codingplayboy</a>
						</div>
					</div>
					<div class="col-6">
											</div>
				</div><!-- .row -->
			</div>
		</div>
	</footer><!-- #colophon -->
	
			<a href="http://blog.codingplayboy.com/2017/12/02/react_fiber/#masthead" id="scroll-up" style="display: block;"><span class="icon-arrow-up"></span></a>
		
</div><!-- #page -->

<script type="text/javascript" src="./React Fiber初探 – 熊建刚的博客_files/form.js"></script>
<link rel="stylesheet" id="hljstheme-css" href="./React Fiber初探 – 熊建刚的博客_files/default.css" type="text/css" media="all">
<script type="text/javascript">
/* <![CDATA[ */
var tocplus = {"smooth_scroll":"1","visibility_show":"\u663e\u793a","visibility_hide":"\u9690\u85cf","width":"Auto"};
/* ]]> */
</script>
<script type="text/javascript" src="./React Fiber初探 – 熊建刚的博客_files/front.min.js"></script>
<script type="text/javascript" src="./React Fiber初探 – 熊建刚的博客_files/main.js"></script>
<script type="text/javascript" src="./React Fiber初探 – 熊建刚的博客_files/comment-reply.min.js"></script>
<script type="text/javascript" src="./React Fiber初探 – 熊建刚的博客_files/wp-embed.min.js"></script>
<script type="text/javascript" src="./React Fiber初探 – 熊建刚的博客_files/highlight.common.pack.js"></script>
    <style>pre.hljs {padding: 5px;}
pre.hljs code {}</style>
    <script type="text/javascript">
    (function($, window) {
        var init_fn_flag = false;
        var init_fn = (function() {
            if (init_fn_flag)
                return;
            init_fn_flag = true;
             hljs.configure({"tabReplace":"    "});
            $('pre code').each(function(i, block) {
                hljs.highlightBlock(block);
            });
        });
        $(document).ready(init_fn);
        $(window).on("load", init_fn);
    })(jQuery, window);
    </script>


</body></html>