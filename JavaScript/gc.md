V8 采用了一个分代（Generational）垃圾回收器，将内存堆分割为新生代（Young Generation）和老生代（Old Generation）。新生代的对象为存活时间较短的对象，老生代中的对象为存活时间较长或常驻内存的对象。由于绝大多数对象的生存期很短，只有少数对象的生存期较长，这种分代策略能使垃圾回收器对新生代对象执行一些规则的、小的垃圾回收（被称为Scavenge）。V8 分别对新生代对象和老生代对象使用不同的垃圾回收算法来提升垃圾回收的效率。

对象起初会被分配在新生代内存区（通常很小，只有 1-8 MB，具体根据任务分配）。大多数的对象被分配在这里，这个区域很小但是垃圾回收特别频繁。新生代使用半空间（Semi-space）分配策略，其中新对象最初分配在新生代的活跃半空间内。一旦半空间已满，一个Scavenge 操作将活跃对象移出到其他半空间中，被认为是长期驻存的对象，并被晋升为老生代。一旦活跃对象已被移出，则在旧的半空间中剩下的任何死亡对象被丢弃。

老生代所保存的对象大多数是生存周期很长的甚至是常驻内存的对象，而且老生代占用的内存较多，通常包含有上百 MB 的数据。因此，V8 在老生代中的垃圾回收采用标记- 清除（Mark-Sweep）和Mark-Compact 相结合的策略。

当老生代中的活动对象增长超过了一个预设的限制的时候，将对堆栈执行一个大回收。老生代垃圾回收使用 Mark-Sweep 策略，其采用了几种优化方法来改善延迟和内存消耗。标记时间取决于必须标记的活跃对象的数目，对于一个大的 web 应用，整个堆栈的标记可能需要超过 100ms。由于全停顿会造成了浏览器一段时间无响应，所以 V8 使用了一种增量标记的方式标记活跃对象，将完整的标记拆分成很多小的步骤，每做完一部分就停下来，让JavaScript 的应用线程执行一会，这样垃圾回收与应用线程交替执行。V8 可以让每个标记步骤的持续时间低于5ms。

有四个主要的操作:

- 新生代的 Scavenge, 这通常是快速的(并发清理)
- 增量标记
- 完整垃圾回收
- 带整理的垃圾回收

老生代回收器并行的去标记和清除对象，并发的去整理内存和更新活动对象的指针

引用: 

- https://v8.dev/blog/trash-talk
- https://queue.acm.org/detail.cfm?id=2977741